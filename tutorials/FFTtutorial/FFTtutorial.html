<!DOCTYPE html>  
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>FFTtutorial</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
/* 
   This document has been created with Marked.app <http://markedapp.com>, Copyright 2011 Brett Terpstra
   Please leave this notice in place, along with any additional credits below.
   ---------------------------------------------------------------
   Title: GitHub
   Author: Brett Terpstra
   Description: Github README style. Includes theme for Pygmentized code blocks.
*/
html, body {
    color: black;
}

* {
    margin: 0;
    padding: 0;
}

body {
    font-size: 18px;
    font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
    -webkit-font-smoothing: antialiased;
    line-height: 1.4;
    padding: 3px;
    background: #fff;
    border-radius: 3px;
    -moz-border-radius: 3px;
    -webkit-border-radius: 3px;
}

p {
    margin: 1em 0;
    font-size: 18px;
}

a {
    color: #4183c4;
    text-decoration: none;
}

#wrapper {
    background-color: #fff;
    padding: 0 30px;
    margin: 15px;
}

#wrapper {
    font-size: 14px;
    line-height: 1.6;
}

#wrapper>*:first-child {
    margin-top: 0!important;
}

#wrapper>*:last-child {
    margin-bottom: 0!important;
}

h1,h2,h3,h4,h5,h6 {
    margin: 0;
    padding: 0;
}

h1 {
    margin: 15px 0;
    padding-bottom: 2px;
    font-size: 28px;
    //border-bottom: 1px solid #eee;
}

h2 {
    margin: 20px 0 10px 0;
    font-size: 22px;
}

h3 {
    margin: 20px 0 10px 0;
    padding-bottom: 2px;
    font-size: 20px;
    border-bottom: 1px solid black; //#ddd;
}

h4 {
    font-size: 18px;
    line-height: 5px;
    padding: 25px 0 22px;
    font-weight: bold;
    text-transform: uppercase;
}

h5 {
    font-size: 13px;
    line-height: 26px;
    padding: 18px 0 0;
    font-weight: bold;
    text-transform: uppercase;
}

h6 {
    color: #666;
    font-size: 18px;
    line-height: 26px;
    padding: 18px 0 0;
    font-weight: normal;
    font-variant: italic;
}

hr {
    color: black;
    border-color: black;
    background-color: black;
    height: 0.5px;
    margin: 20px 0;
    padding: 0;
}

#wrapper>h2:first-child,#wrapper>h1:first-child,#wrapper>h1:first-child+h2 {
    border: 0;
    margin: 0;
    padding: 0;
}

#wrapper>h3:first-child,#wrapper>h4:first-child,#wrapper>h5:first-child,#wrapper>h6:first-child {
    margin: 0;
    padding: 0;
}

h4+p,h5+p,h6+p {
    margin-top: 0;
}

li p.first {
    display: inline-block;
}

ul,ol {
    margin: 4px 0 4px 5px;
}

ul li,ol li {
    font-size: 18px;
    margin-top: 1px;
    margin-bottom: 1px;
}

ul li>*:last-child,ol li>*:last-child {
    margin-bottom: 0;
}

ul li>*:first-child,ol li>*:first-child {
    margin-top: 0;
}

#wrapper>ul,#wrapper>ol {
    margin-top: 21px;
    margin-left: 36px;
}

dl {
    margin: 0;
    padding: 20px 0 0;
}

dl dt {
    font-size: 14px;
    font-weight: bold;
    line-height: normal;
    margin: 0;
    padding: 20px 0 0;
}

dl dt:first-child {
    padding: 0;
}

dl dd {
    font-size: 13px;
    margin: 0;
    padding: 3px 0 0;
}

blockquote {
    margin: 14px 0;
    border-left: 4px solid #ddd;
    padding-left: 11px;
    color: #555;
}

table {
    border-collapse: collapse;
    margin: 20px 0 0;
    padding: 0;
}

table tr {
    border-top: 1px solid #ccc;
    background-color: #fff;
    margin: 0;
    padding: 0;
}

table tr:nth-child(2n) {
    background-color: #f8f8f8;
}

table tr th,table tr td {
    border: 1px solid #ccc;
    text-align: left;
    margin: 0;
    padding: 6px 13px;
}

img {
    max-width: 100%;
    height: auto
}

code,tt {
    margin: 0 2px;
    padding: 2px 5px;
    white-space: nowrap;
    border: 1px solid #ccc;
    background-color: #f8f8f8;
    border-radius: 3px;
    -moz-border-radius: 3px;
    -webkit-border-radius: 3px;
    font-size: 16px
}

pre>code {
    margin: 0;
    padding: 0;
    white-space: pre;
    border: none;
    background: transparent;
    font-size: 15px
}

.highlight pre,pre {
    background-color: #f8f8f8;
    border: 1px solid #ccc;
    font-size: 13px;
    line-height: 19px;
    overflow: auto;
    padding: 6px 10px;
    border-radius: 3px;
    -moz-border-radius: 3px;
    -webkit-border-radius: 3px;
}

#wrapper>pre,#wrapper>div.highlight {
    margin: 10px 0 0;
}

pre code,pre tt {
    background-color: transparent;
    border: none;
}

#wrapper {
    background-color: #fff;
    border: 1px solid #CACACA;
    padding: 30px;
}

.poetry pre {
    font-family: Georgia, Garamond, serif !important;
    font-style: italic;
    font-size: 110% !important;
    line-height: 1.6em;
    display: block;
    margin-left: 1em;
}

.poetry pre code {
    font-family: Georgia, Garamond, serif !important;
    word-break: break-all;
	word-break: break-word; /* Non standard for webkit */
	-webkit-hyphens: auto;
	-moz-hyphens: auto;
	hyphens: auto;
    white-space: pre-wrap;
}

sup,sub,a.footnote {
    font-size: 1.4ex;
    height: 0;
    line-height: 1;
    vertical-align: super;
    position: relative;
}

sub {
    vertical-align: sub;
    top: -1px;
}

@media print {
    body {
        background: #fff;
    }

    img, pre, blockquote, table, figure {
        page-break-inside: avoid
    }

    #wrapper {
        background: #fff;
        border: none;
    }

    code {
        background-color: #fff;
        color: #444!important;
        padding: 0 .2em;
        border: 1px solid #DEDEDE;
    }

    pre code {
        background-color: #fff!important;
        overflow: visible;
    }

    pre {
        background: #fff;
    }
}

@media screen {
    body.inverted, .inverted #wrapper, .inverted hr
.inverted p,.inverted td,.inverted li,.inverted h1,.inverted h2,.inverted h3,.inverted h4,.inverted h5,.inverted h6,.inverted th,.inverted .math,.inverted caption,.inverted dd,.inverted dt, .inverted blockquote {
        color: #eee !important;
        border-color: #555
    }

    .inverted td, .inverted th {
        background: #333;
    }

    .inverted pre,.inverted code, .inverted tt {
        background: #444!important;
    }

    .inverted h2 {
        border-color: #555
    }

    .inverted hr {
        border-color: #777;
        border-width: 1px !important;
    }

    ::selection {
        background: rgba(157, 193, 200,.5)
    }

    h1::selection {
        background-color: rgba(45, 156, 208, .3)
    }

    h2::selection {
        background-color: rgba(90, 182, 224, .3)
    }

    h3::selection,
    h4::selection,
    h5::selection,
    h6::selection,li::selection,ol::selection {
        background-color: rgba(133, 201, 232, .3)
    }

    code::selection {
        background-color: rgba(0,0,0,.7);
        color: #eee
    }

    code span::selection {
        background-color: rgba(0,0,0,.7) !important;
        color: #eee !important
    }

    a::selection {
        background-color: rgba(255, 230, 102,.2)
    }

    .inverted a::selection {
        background-color: rgba(255, 230, 102,.6)
    }

    td::selection,th::selection,caption::selection {
        background-color: rgba(180, 237, 95, .5);
    }

    .inverted {
        background: #0b2531;
    }

    .inverted #wrapper,.inverted {
        background: rgba(37, 42, 42, 1)
    }

    .inverted a {
        color: rgba(172, 209, 213, 1);
    }
}

.highlight .c {
    color: #998;
    font-style: italic;
}

.highlight .err {
    color: #a61717;
    background-color: #e3d2d2;
}

.highlight .k {
    font-weight: bold;
}

.highlight .o {
    font-weight: bold;
}

.highlight .cm {
    color: #998;
    font-style: italic;
}

.highlight .cp {
    color: #999;
    font-weight: bold;
}

.highlight .c1 {
    color: #998;
    font-style: italic;
}

.highlight .cs {
    color: #999;
    font-weight: bold;
    font-style: italic;
}

.highlight .gd {
    color: #000;
    background-color: #fdd;
}

.highlight .gd .x {
    color: #000;
    background-color: #faa;
}

.highlight .ge {
    font-style: italic;
}

.highlight .gr {
    color: #a00;
}

.highlight .gh {
    color: #999;
}

.highlight .gi {
    color: #000;
    background-color: #dfd;
}

.highlight .gi .x {
    color: #000;
    background-color: #afa;
}

.highlight .go {
    color: #888;
}

.highlight .gp {
    color: #555;
}

.highlight .gs {
    font-weight: bold;
}

.highlight .gu {
    color: #800080;
    font-weight: bold;
}

.highlight .gt {
    color: #a00;
}

.highlight .kc {
    font-weight: bold;
}

.highlight .kd {
    font-weight: bold;
}

.highlight .kn {
    font-weight: bold;
}

.highlight .kp {
    font-weight: bold;
}

.highlight .kr {
    font-weight: bold;
}

.highlight .kt {
    color: #458;
    font-weight: bold;
}

.highlight .m {
    color: #099;
}

.highlight .s {
    color: #d14;
}

.highlight .na {
    color: #008080;
}

.highlight .nb {
    color: #0086B3;
}

.highlight .nc {
    color: #458;
    font-weight: bold;
}

.highlight .no {
    color: #008080;
}

.highlight .ni {
    color: #800080;
}

.highlight .ne {
    color: #900;
    font-weight: bold;
}

.highlight .nf {
    color: #900;
    font-weight: bold;
}

.highlight .nn {
    color: #555;
}

.highlight .nt {
    color: #000080;
}

.highlight .nv {
    color: #008080;
}

.highlight .ow {
    font-weight: bold;
}

.highlight .w {
    color: #bbb;
}

.highlight .mf {
    color: #099;
}

.highlight .mh {
    color: #099;
}

.highlight .mi {
    color: #099;
}

.highlight .mo {
    color: #099;
}

.highlight .sb {
    color: #d14;
}

.highlight .sc {
    color: #d14;
}

.highlight .sd {
    color: #d14;
}

.highlight .s2 {
    color: #d14;
}

.highlight .se {
    color: #d14;
}

.highlight .sh {
    color: #d14;
}

.highlight .si {
    color: #d14;
}

.highlight .sx {
    color: #d14;
}

.highlight .sr {
    color: #009926;
}

.highlight .s1 {
    color: #d14;
}

.highlight .ss {
    color: #990073;
}

.highlight .bp {
    color: #999;
}

.highlight .vc {
    color: #008080;
}

.highlight .vg {
    color: #008080;
}

.highlight .vi {
    color: #008080;
}

.highlight .il {
    color: #099;
}

.highlight .gc {
    color: #999;
    background-color: #EAF2F5;
}

.type-csharp .highlight .k {
    color: #00F;
}

.type-csharp .highlight .kt {
    color: #00F;
}

.type-csharp .highlight .nf {
    color: #000;
    font-weight: normal;
}

.type-csharp .highlight .nc {
    color: #2B91AF;
}

.type-csharp .highlight .nn {
    color: #000;
}

.type-csharp .highlight .s {
    color: #A31515;
}

.type-csharp .highlight .sc {
    color: #A31515;
}/*

github.com style (c) Vasily Polovnyov <vast@whiteants.net>

*/

pre code {
  display: block; padding: 0.5em;
  color: #000;
  background: #f8f8ff
}

pre .comment,
pre .template_comment,
pre .diff .header,
pre .javadoc {
  color: #998;
  font-style: italic
}

pre .keyword,
pre .css .rule .keyword,
pre .winutils,
pre .javascript .title,
pre .lisp .title,
pre .subst {
  color: #000;
  font-weight: bold
}

pre .ruby .keyword {
  font-weight: normal
}

pre .number,
pre .hexcolor {
  color: #40a070
}

pre .string,
pre .tag .value,
pre .phpdoc,
pre .tex .formula {
  color: #d14
}

pre .title,
pre .id {
  color: #900;
  font-weight: bold
}

pre .javascript .title,
pre .lisp .title,
pre .subst {
  font-weight: normal
}

pre .class .title,
pre .haskell .label,
pre .tex .command {
  color: #458;
  font-weight: bold
}

pre .class .params {
	color: #000;
}

pre .tag,
pre .tag .title,
pre .rules .property,
pre .django .tag .keyword {
  color: #000080;
  font-weight: normal
}

pre .attribute,
pre .variable,
pre .instancevar,
pre .lisp .body {
  color: #008080
}

pre .regexp {
  color: #009926
}

pre .class {
  color: #458;
  font-weight: bold
}

pre .symbol,
pre .ruby .symbol .string,
pre .ruby .symbol .keyword,
pre .ruby .symbol .keymethods,
pre .lisp .keyword,
pre .tex .special,
pre .input_number {
  color: #0086b3
}

pre .ruby .identifier .keyword,
pre .ruby .identifier .keymethods {
  color: #0086b3;
}

pre .ruby .constant {
  color: #008080;
}

pre .builtin,
pre .built_in,
pre .lisp .title {
  color: #0086b3
}

pre .preprocessor,
pre .pi,
pre .doctype,
pre .shebang,
pre .cdata {
  color: #999;
  font-weight: bold
}

pre .deletion {
  background: #fdd
}

pre .addition {
  background: #dfd
}

pre .diff .change {
  background: #0086b3
}

pre .chunk {
  color: #aaa
}

pre .tex .formula {
  opacity: 0.5;
}
</style>
      <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>
      <script>
          MathJax.Hub.Config({
                             config: ["MMLorHTML.js"],
                             extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js"],
                             jax: ["input/TeX"],
                             tex2jax: {
                             inlineMath: [ ['$','$'], ["\\(","\\)"] ],
                             displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
                             processEscapes: false
                             },
                             TeX: {
                             TagSide: "right",
                             TagIndent: ".8em",
                             MultLineWidth: "85%",
                             equationNumbers: {
                             autoNumber: "AMS",
                             },
                             unicode: {
                             fonts: "STIXGeneral,'Arial Unicode MS'" 
                             }
                             },
                             showProcessingMessages: false
                             });
          </script>
</head>
<body class="normal">
  <div id="wrapper">
      <hr />

<h1 id="fourieranalysistutorial">Fourier analysis tutorial</h1>

<p><em>Written by Mike Shadlen, updates by Adrienne Fairhall</em></p>

<hr />

<h1 id="introduction">Introduction</h1>

<p>The Fourier transform is probably the most important transform in applied math. It takes a function, typically of time or space, and expresses it as a function of frequency. The goals of this tutorial are to make you comfortable with what a Fourier transform is, how to compute one, and why it is useful. We will focus on three topics: </p>

<ol>
<li>definition and properties of the Fourier transform.</li>
<li>convolution.</li>
<li>the connection between the two.</li>
</ol>

<h3 id="parti.thediscretefouriertransform">Part I. The discrete Fourier transform</h3>

<p>A transform is (usually) a reversible mapping from one set of values to another set of values. The Fourier transform takes a list of intensities at points in time (or space) and transform them to a list of &#8220;intensities&#8221; at different frequencies. Thinking about a signal as a collection of time intensities, each associated with its own time point, is simple enough. Thinking about a signal as a list of intensities, each associated with its own sinusoidal frequency, is also convenient. Perhaps because of the way our auditory system is organized, we find thinking in frequency quite natural and intuitive. You do it every day when you adjust the bass and treble on your stereo &#8211; or better yet, if you adjust knobs on an equalizer. You can imagine that describing a signal in terms of its frequencies can be convenient in certain settings. That&#8217;s what the Fourier transform is for. </p>

<p>We should emphasize from the start that taking a Fourier transform (FT, for short) does not change the signal; it just represents it differently. To be concrete, suppose there is some electrical signal that we want to describe over the phone to a friend. We could list the voltages at each time or we could list the amplitudes and phases of each of the frequencies that comprise the signal. It&#8217;s the same signal, just a different list of numbers. Sometimes it is much faster and simpler to use one type of description than the other.</p>

<p>Often, when we describe signals, we don&#8217;t think of them as lists of numbers but rather as functions of time. Of course, the function can be viewed as a way to generate a list of values at each time point. We can also use a function to describe the list of &#8220;intensities&#8221; at each frequency in a Fourier transform. The two functions are called Fourier transform pairs. For example, suppose <span class="math">\(s(t)\)</span> is some function of time (it has a value at each time point). And suppose that you could describe the same signal by &#8220;intensities&#8221; of frequency, <span class="math">\(w\)</span>, using a function, <span class="math">\(S(w)\)</span>. Then, we say that <span class="math">\(s(t)\)</span> and <span class="math">\(S(w)\)</span> are a Fourier transform pair. Or we say that <span class="math">\(S(w)\)</span> is the Fourier transform of <span class="math">\(s(t)\)</span>, or that <span class="math">\(s(t)\)</span> is the inverse Fourier transform of <span class="math">\(S(w)\)</span>. When we started by saying that a transform is a reversible mapping, what this means is that <span class="math">\(S(w)\)</span> is the unique Fourier transform of <span class="math">\(s(t)\)</span> and <span class="math">\(s(t)\)</span> is the unique inverse transform of <span class="math">\(S(w)\)</span>.</p>

<p>Our goal here is both to help you to get comfortable with the meaning of the Fourier transform, and to get you used to using the numerical function FFT (fast Fourier transform) in Matlab. If you get everything about what that Matlab function returns to you, you&#8217;ll pretty much have mastered what you need to know.</p>

<p>Before we look at FTs, let&#8217;s get comfortable with a few illustrative functions. Since we&#8217;ll be doing everything numerically in this tutorial, we will focus here on discrete functions. What is meant by this is that we are going to make the argument of the function, say time, take discrete values. We&#8217;re used to thinking of time t occupying some continuous interval on the real number line, but here we&#8217;ll be thinking of time as integers, multiplied by some constant or scaling factor. In fact this is overwhelmingly going to be the case whenever you are thinking about real data: the values are always sampled at some particular finite sampling rate. </p>

<pre><code class="matlab">clear all</code></pre>

<p>Define a discrete time axis. The spacing is <span class="math">\(dt\)</span></p>

<pre><code class="matlab">dt = .01;       </code></pre>

<p>our units are seconds. So each integer time point is scaled to represent <span class="math">\(dt\)</span> sec</p>

<pre><code class="matlab">tmax = 1
t = [0:dt:tmax-dt]&apos;;</code></pre>

<p>Notice that we are sampling time at a rate of <span class="math">\(1/dt\)</span>. This will be important later.</p>

<pre><code class="matlab">samplingRate = 1/dt     in Hz</code></pre>

<p>Think of a discrete function as a series of weights at each of the points in <span class="math">\(t\)</span>. Let&#8217;s look at some functions this way. Here&#8217;s a gaussian profile centered at 0.5</p>

<pre><code class="matlab">f1 = exp(-.5*(t-.5).^2 / (.05)^2);

figure(1),clf,hold on;
h = plot(t,f1);
xlabel(&apos;Time [s]&apos;);
ylabel(&apos;Amplitude&apos;);</code></pre>

<p><em>Pause here.</em> The function is drawn continuously: there are no gaps. That&#8217;s because Matlab drew a line, or interpolated, between the values at the discrete time points. In reality, what we know about the function is just a bunch of heights at each of the time points. We can use the stem function to highlight this fact.</p>

<pre><code class="matlab">stem(t,f1,&apos;filled&apos;);</code></pre>

<p>and we can toggle the smooth curve off</p>

<pre><code class="matlab">set(h,&apos;Visible&apos;,&apos;off&apos;)</code></pre>

<p>Now&#8230; that&#8217;s a discrete function. Each of the points can be thought of as a weight given to the basis set of discrete time points. We represent the function as a list of these weights. Indeed, f1 is a vector.</p>

<pre><code class="matlab">size(f1)</code></pre>

<p>Let&#8217;s remember this function by calling it something mnemonic</p>

<pre><code class="matlab">gaus1 = f1;</code></pre>

<p>Let&#8217;s look at a few more functions</p>

<p><strong>pulse</strong></p>

<pre><code class="matlab">f2 = zeros(size(t));
f2(t&gt;.45 &amp; t&lt;= 0.55) = 1;

figure(1), hold off
stem(t,f2,&apos;filled&apos;)
xlabel(&apos;Time [s]&apos;)
ylabel(&apos;Amplitude&apos;)
pulse1 = f2;</code></pre>

<p><strong>sinewaves</strong></p>

<pre><code class="matlab">f3 = sin(2*pi*1*(t-.5));
sin1 = f3;
stem(t,f3,&apos;filled&apos;)

f4 = cos(2*pi*10*(t-.5));
cos10 = f4;
stem(t,f4,&apos;filled&apos;)</code></pre>

<p>This looks a lot better interpolated!</p>

<pre><code class="matlab">plot(t,f4)</code></pre>

<p>the sum (I&#8217;m not giving this a function name)</p>

<pre><code class="matlab">sos = .5*f3 + f4;
plot(t,sos)</code></pre>

<p><strong>exponential</strong></p>

<pre><code class="matlab">tau = .1
f5 = exp(-(t-.5)/tau);
f5(t&lt;.5) = 0;
exp1 = f5;
stem(t,f5,&apos;filled&apos;)</code></pre>

<p><strong>discrete delta function</strong> &#8211; take special note of this one.</p>

<pre><code class="matlab">f6 = zeros(size(t));
f6(min(find(t&gt;=.5))) = 1;
stem(t,f6,&apos;filled&apos;)
delt1 = f6;</code></pre>

<p><strong>comb(.1t) function.</strong> This is a sampling function or strobe function that turns on at a rate % of 10 times per second (10 Hz). But it is also a sum of discrete delta functions.</p>

<pre><code class="matlab">f7 = mod(t,.1)==0;

comb10 = f7;

stem(t,comb10,&apos;filled&apos;)</code></pre>

<h4 id="reflectionpoint.">Reflection point.</h4>

<p>You have yet to see a Fourier transform. You are supposed to simply marvel at the idea of discreteness. And here is the one thing extra that you need to think about. All of the functions above can be thought of as sums of discrete delta functions with appropriately chosen weights. The most obvious example is the comb function, as we have already noted. But all the functions are just values at discrete time points. So all can be thought of as sums of delta functions. In fact, a discrete function is exactly this: the multiplication of a continuous function by <code>comb(d*t)</code>, where d is the gap between samples (i.e., the reciprocal of the sampling rate). We will return to this point later.</p>

<p>Another important point to make before moving on. Let&#8217;s recall the idea of a BASIS SET from linear algebra. As you know, a coordinate frame is a set of vectors which span a given space: e.g. in the plane, we have an x-axis, and a y-axis. So to say that a point in the plane is (3,2) means that our vector contains 3 units along the x-axis, and 2 units along the y-axis. </p>

<p>A functional basis set is just a coordinate set for the space of functions. What does this mean? Let&#8217;s take some arbitrary data sequence, a bunch of values from time zero to time <span class="math">\(T\)</span>. Since it is discretized, we have <span class="math">\(N\)</span> points in our data: a value for at each time, <span class="math">\(0, dt, 2dt, 3dt,.. (N - 1)dt\)</span>. Let&#8217;s now think about this data as an <span class="math">\(N\)</span>-dimensional vector, and plot it as a single point in an <span class="math">\(N\)</span>-dimensional space. What is the coordinate system in which we have plotted our function? The unit vectors are the set of delta functions at each time, <span class="math">\(t = i dt\)</span>, for <span class="math">\(i\)</span> ranging from <span class="math">\(0\)</span> to <span class="math">\(N-1\)</span>. So axis one means how strong was the function at time <span class="math">\(t = 0\)</span>, axis 2 is how strong the function was at time <span class="math">\(t = dt\)</span>, and so on. If we write these as vectors they will look just like Euclidean coordinate axes: <span class="math">\([1 0 0 0 0 0 ...], [0 1 0 0 0 ...]\)</span>, etc. Remember that an important property of many useful coordinate systems is that the axes are orthogonal: the <span class="math">\(x\)</span> vector has exactly zero projection onto the <span class="math">\(y\)</span> vector; the dot product of the <span class="math">\(x\)</span> vector with the <span class="math">\(y\)</span> vector is zero. Similarly for our delta function coordinate system. The delta function at time <span class="math">\(t\)</span> is independent of the delta function at time <span class="math">\(t'\)</span> if <span class="math">\(t\)</span> is not the same as <span class="math">\(t'\)</span> the dot product of these two functions is zero. As we said already, any function can be written in this &#8220;time&#8221; basis by summing up weighted delta functions.</p>

<p>Now, let&#8217;s move onto Fourier transforms. We had better start by defining it. As we&#8217;ve said, calling it a transform already gives away something important. The function or data we&#8217;re describing is not changed; it&#8217;s just expressed differently. Just like when you rotate something &#8211;you don&#8217;t change the structure of the thing you rotated. </p>

<p>So now, instead of thinking of the function as a list of weights at the discrete time samples, we would now like to think of it as a list of &#8220;weights&#8221; on sinusoids. In other words, since the time representation was just one choice of coordinate systems, we can just as well represent our data function, or N-dimensional point, in some other coordinate system. The Fourier transform is a method for representing our data in another set of axes, where the axes are sines and cosines rather than delta functions. </p>

<p>This is done in a way that will need a little unpacking. Let&#8217;s look at the definition of the Fourier transform <span class="math">\(F(w)\)</span> of a continuous function <span class="math">\(f(t)\)</span>:</p>

<p>$$F(w) = \frac{1}{\sqrt{2\pi}} f(t) \int_{-\infty}^{\infty}\exp( - iwt)dt$$</p>

<p>The integral here is the equivalent for a continuous function of a dot product or projection. So the idea is that we project our data function against the basis function <span class="math">\(e^{-i \omega t}\)</span>, where <span class="math">\(\omega\)</span> is frequency; one basis function for every value of <span class="math">\(\omega\)</span>. So how is this sines and cosines? Remember back to the olden days when you first met complex numbers. Remember Euler&#8217;s identity:</p>

<p>$$e^{ix} = cos(x) + i * sin(x)$$ </p>

<p>Let&#8217;s have a look at some examples:</p>

<pre><code class="matlab">exp(i*0.5)
exp(i*pi)
exp(i*-pi)
exp(i*pi/2)</code></pre>

<p>All of these are complex numbers, but with different real and imaginary parts. (If the above didn&#8217;t give you back a complex number, try </p>

<pre><code class="matlab">clear i</code></pre>

<p>in case you have redefined <code>i</code> somehow as a real number.)</p>

<p>I included some particular cases where the real or the imaginary part is zero. So what is this i thing? It&#8217;s telling you that this is really a two-component number, with two &#8220;axes&#8221;, the &#8220;real&#8221; axis and the &#8220;imaginary&#8221; axis, where the length of the number <span class="math">\(e^{ix}\)</span> along the real axis is <span class="math">\(cos(x)\)</span>, and its length along the imaginary axis is <span class="math">\(sin(x)\)</span>. We could write it in vector notation as (<span class="math">\(cos(x)\)</span>, <span class="math">\(sin(x)\)</span>) and plot it as a point on a plane. The length of the vector is 1, since</p>

<p>$$cos^2(x) + sin^2(x) = 1$$</p>

<p>If we want a longer vector, we scale the whole thing by some amplitude $A: A e^{ix}$. The value of <span class="math">\(x\)</span> is the phase in radians.</p>

<p>So: every complex number is really 2-dimensional, and every <span class="math">\(e^{- i \omega t}\)</span> for a given <span class="math">\(\omega\)</span> will give us two components, one real, corresponding to the cosine at frequency <span class="math">\(\omega)\)</span>, and one imaginary, corresponding to the sine. This is just an elegant way to capture the issue that for every frequency, we need two values. Why? Because every frequency component is specified both by an AMPLITUDE and a PHASE. Using both a sine and a cosine component allows us to construct any arbitrary phase. Remember another fact from your dim dark past: the sin identities. Do you remember:</p>

<p>$$sin (x+y) = sin(x) cos(y) + sin(y) cos(x)$$</p>

<p>so let&#8217;s say <span class="math">\(x\)</span> is <span class="math">\(t\)</span> and <span class="math">\(y\)</span> is some phase <span class="math">\(p\)</span>, then</p>

<p>$$a sin (t + p) = a * cos(p)*sin(t) + a * sin(p)cos(t) ,$$</p>

<p>where <span class="math">\(a * cos(p)\)</span> and <span class="math">\(a * sin(p)\)</span> now become the coefficients of the sine and cosine functions. Again, the total amplitude is <span class="math">\(a * \sqrt(sin(p)^2 + cos(p)^2) = a\)</span> ! So representing phase as well as overall amplitude is why you need both a sine and a cosine at every frequency. Using complex numbers for each frequency is just a way to do this neatly and elegantly.</p>

<p>Let&#8217;s see that in action. Let&#8217;s look at the real and imaginary parts of the function <span class="math">\(e^{i \omega t}\)</span>, for <span class="math">\(\omega = 2 \pi\)</span>. (this frequency is angular frequency! here we will generally take out the <span class="math">\(2 \pi\)</span> factor, <span class="math">\(\omega = 2 \pi f\)</span>, and work in hertz..)</p>

<pre><code class="matlab">figure(2), clf
subplot(2,1,1); plot(t,real(exp(i*2*pi*t))); xlabel(&apos;t&apos;); title(&apos;Real part of exp(iwt)&apos;)
subplot(2,1,2); plot(t,imag(exp(i*2*pi*t))); xlabel(&apos;t&apos;); title(&apos;Imaginary part of exp(iwt)&apos;)</code></pre>

<p>Let&#8217;s also look at a fun demo showing how you shift the phase of a sine or cosine function by multiplying by <span class="math">\(e^{i \phi}\)</span>, where <span class="math">\(\phi\)</span> is the phase. Below the graph you&#8217;ll see the polar representation of <span class="math">\(e^{i \phi}\)</span>.</p>

<pre><code class="matlab">figure(4), clf
clear ax
ax(1) = subplot(3,1,1);
ax(2) = subplot(2,3,5);
axis square

phi = [0:.01:2*pi]&apos;;  % take phase shifts going right around the circle.
polar(phi,ones(size(phi)));
polar([0 0],[0,1])
set(gcf,&apos;CurrentAxes&apos;,ax(1))
plot(t,cos(2*pi*t))
set(gcf,&apos;CurrentAxes&apos;,ax(2))
nsteps = 100;        %  change this to alter the speed of the demo

for j = 1:nsteps
	phi = j* 2*pi/nsteps;   we are incrementing the phase shift
	set(gcf,&apos;CurrentAxes&apos;,ax(1))
	plot(t,real(exp(i*(2*pi*t + phi))),&apos;r&apos;,&apos;LineWidth&apos;,3)

	set(gcf,&apos;CurrentAxes&apos;,ax(2))
	polar([0 phi],[0 1],&apos;r&apos;),hold on
	polar([0 0 phi],[0 cos(phi) 1],&apos;k--&apos;), hold off

	pause
	drawnow

end</code></pre>

<p>So what&#8217;s the upshot: by projecting onto <span class="math">\(e^{i \omega t}\)</span>, we are actually projecting against both a sine and a cosine function of frequency <span class="math">\(\omega\)</span>. Remember that a sine, or any other function, is just a linear sum of the delta functions so this is just a linear transformation. Even better, since sines and cosines of different frequencies are orthogonal, the sines and cosines form an orthogonal basis set. The sines and cosines are not the only functions that we could choose for our alternative basis set, but they are useful so often that the Fourier transform is one of the most commonly used of all possibilities. When we study dimensionality reduction, we will talk about some other alternatives.</p>

<p>Let&#8217;s look at some examples.</p>

<p>Let&#8217;s start with a cosine function. What do you expect to see? Let&#8217;s bung the cosine function into Matlab&#8217;s function fft and plot. I will use a frequency f of 10 Hz. Worth mentioning now that in the above we have used the symbol <span class="math">\(\omega\)</span> for omega, which is the angular frequency. Frequency in Hz is related to angular frequency by a factor of <span class="math">\(2 \pi\)</span>, <span class="math">\(\omega = 2 \pi f\)</span>, which is often useful to factor out. </p>

<pre><code class="matlab">y = cos(2*pi*10*t);

figure(2), clf
subplot(1,2,1)
plot(t,y)
xlabel(&apos;Time&apos;)

subplot(1,2,2)
fcos = fft(y);
plot(fcos); ylabel(&apos;Fourier transform of cosine function&apos;)</code></pre>

<p>What the *$&amp;#^? (pardon my Australian.)
Let&#8217;s see what you have plotted.</p>

<pre><code class="matlab">whos fcos</code></pre>

<p>Ah ha. The fft of y is, of course, a complex array, so has a real and imaginary part. When you use plot, matlab plots the real part vs the imaginary part. So let&#8217;s plot each of the two parts separately.</p>

<pre><code class="matlab">subplot(1,2,1); 
plot(real(fcos));
ylabel(&apos;Real part of fft(cos t)&apos;);
subplot(1,2,2); 
plot(imag(fcos));
ylabel(&apos;Imaginary part of ft(cos t)&apos;);</code></pre>

<p>Now we&#8217;re getting somewhere. The real part has two big spikes; the imaginary part is tiny, really just zero except for numerical noise. Now, why and where are those two big spikes? We put in a 100-dimensional purely real data vector, and got out a 100-dimensional complex vector, meaning 200 values. That seems to be twice as many as we need. We&#8217;ll talk more about this later. We have obtained a function of frequency, but what are the labels on the frequency axis? </p>

<p>Let&#8217;s recall yet another high school fact: how do you write a cosine in terms of complex numbers? It&#8217;s just a rewriting of the definition (known as the Euler identity) we used above. </p>

<p>Remember: </p>

<p>$$cos(a) = \frac{e^{ia} + e^{-ia}}{2}$$</p>

<p>Similarly, </p>

<p>$$sin(a) = \frac{e^{ia} - e^{-ia}}{2i}$$</p>

<p>Our transform scans over <span class="math">\(\omega\)</span> (or <span class="math">\(f\)</span>, looking for nonzero values. Under the integral sign, we have</p>

<p>$$e^{i \omega t}*e^{i 2 \pi 10 t} + e^{ -i 2 \pi 10 t}= e^{i (\omega - 2 \pi 10) t} + e^{i(\omega + 2 \pi 10) t}$$</p>

<p>The integral of an imaginary exponential turns out to be zero unless what is in the exponent exactly cancels, giving you <span class="math">\(e^{0}\)</span> = 1. This happens for the first term at <span class="math">\(\omega = 2 \pi 10,\)</span> and for the second term at <span class="math">\(\omega = - 2 \pi 10\)</span>.</p>

<p>So, we expect two peaks for our transform, at <span class="math">\(f = 10\)</span> and at <span class="math">\(f = -10\)</span>. </p>

<p>Why do the peaks show up in the output array at index 10 and 90? It turns, out that the negative frequencies are arranged after the positive ones. The ordering runs 0 through to max frequency <span class="math">\(\Omega\)</span>, then from <span class="math">\(-\Omega\)</span> to -min frequency. From now on, we&#8217;ll use the Matlab function <code>fftshift</code> to rearrange them in the usual increasing order. </p>

<p>Let&#8217;s have a look at the transform of a sine wave as well: (note here I&#8217;m switching to a plotting form more appropriate for this kind of spiky function, and I&#8217;m scaling the y-axes of the real and imaginary parts by the same amount so we don&#8217;t see all that <span class="math">\(10^{-13}\)</span> stuff)</p>

<pre><code class="matlab">clf;
subplot(2,2,1); 
stem(fftshift(real(fcos)),&apos;filled&apos;);
ylabel(&apos;Real part of ft(cos)&apos;);

subplot(2,2,2); 
stem(fftshift(imag(fcos)),&apos;filled&apos;);
ylabel(&apos;Imaginary part of ft(cos)&apos;);

y = sin(2*pi*10*t);
subplot(2,2,3)
fsin = fft(y);

subplot(2,2,3); 
stem(fftshift(real(fsin)),&apos;filled&apos;);
ylabel(&apos;Real part of ft(sin)&apos;);

subplot(2,2,4); 
stem(fftshift(imag(fsin)),&apos;filled&apos;);
ylabel(&apos;Imaginary part of ft(sin)&apos;);</code></pre>

<p>Just as we should now expect: the large values are in the imaginary part, because of that i in the definition of sine, and include a positive and a negative peak, because of the sign difference between the exponents.</p>

<p>Did you expect that the <span class="math">\(+f\)</span> component would come out with a negative sign? Why?</p>

<p>This is a good moment to think what exactly the minimum and maximum frequencies are. The lowest frequency is determined by the length of the sample. If the sample is of length <span class="math">\(T\)</span>, then the lowest frequency that can be resolved is <span class="math">\(1/T\)</span>. How about the highest frequency? If the sampling rate is <span class="math">\(dt\)</span>, then you cannot specify any frequency higher than <span class="math">\(\frac{1}{2dt}\)</span>. That is because you need at least 2 points to capture an oscillation, one on the up part and one on the down part. This frequency is called the NYQUIST frequency. The Nyquist frequency says that you must sample at least twice as often as the shortest wavelength in your data. In class we&#8217;ll try to look at what happens if your signal contains frequencies higher than your sampling rate.</p>

<p>OK, so let&#8217;s define our frequency axis.</p>

<pre><code class="matlab">nyq = samplingRate/2;
dw = 1/tmax;
fax = -nyq: dw: nyq-dw;</code></pre>

<p>and now finally plot, </p>

<pre><code class="matlab">clf;
subplot(2,2,1); 
stem(fax,fftshift(real(fcos)),&apos;filled&apos;);
set(gca,&apos;YLim&apos;,[-50 50])
ylabel(&apos;Real part of ft(cos wt)&apos;);
xlabel(&apos;Frequency&apos;)

subplot(2,2,2); 
stem(fax,fftshift(imag(fcos)),&apos;filled&apos;);
set(gca,&apos;YLim&apos;,[-50 50])
ylabel(&apos;Imaginary part of ft(cos wt)&apos;);
xlabel(&apos;Frequency&apos;)

y = sin(2*pi*10*t);
subplot(2,2,3)
fsin = fft(y);

subplot(2,2,3); 
stem(fax,fftshift(real(fsin)),&apos;filled&apos;);
set(gca,&apos;YLim&apos;,[-50 50])
ylabel(&apos;Real part of ft(sin wt)&apos;);
xlabel(&apos;Frequency&apos;)

subplot(2,2,4); 
stem(fax,fftshift(imag(fsin)),&apos;filled&apos;);
set(gca,&apos;YLim&apos;,[-50 50])
ylabel(&apos;Imaginary part of ft(sin wt)&apos;);
xlabel(&apos;Frequency&apos;)</code></pre>

<p>OK, let&#8217;s stretch our wings a bit and try some other functions.</p>

<p>A sum of 3 sinusoids!</p>

<pre><code class="matlab">y = sin(2*pi*3*t) + .33 * sin(2*pi*9*t) + .2 * sin(2.*pi*15*t); 
figure(3), clf
subplot(2,2,1)
plot(t,y)
xlabel(&apos;Time&apos;)

subplot(2,2,2)
stem(fax,fftshift(imag(fft(y))),&apos;filled&apos;)
xlabel(&apos;Frequency&apos;)</code></pre>

<p>Notice that the time function is almost square wave like. Its definition makes it crystal clear that it is a sum of three sinusoids. This is pretty easy to see in the Fourier transform. We only plotted the imaginary part as we now know that sines will only give us nonzero imaginary part.</p>

<p>Now let&#8217;s look at each of the functions we&#8217;ve talked about already. For ease of viewing, I will plot some of the time functions with lines that interpolate between the (time or frequency) points. For some functions, I use the stem command to emphasize the discreteness. First, let&#8217;s just plot the overall amplitude (the absolute value of the complex number).</p>

<pre><code class="matlab">figure(3), clf
k = 1;
ax(k) = subplot(7,2,k); k=k+1;
hg(1) = plot(t,f1);

ax(k) = subplot(7,2,k); k=k+1;
hg(2) = plot(fax,fftshift(abs(fft(f1))));
stem(fax,fftshift(abs(fft(f1))),&apos;filled&apos;)

ax(k) = subplot(7,2,k); k=k+1;
hg(3) = plot(t,f2);

ax(k) = subplot(7,2,k); k=k+1;
hg(4) = plot(fax,fftshift(abs(fft(f2))));
stem(fax,fftshift(abs(fft(f2))),&apos;filled&apos;)

ax(k) = subplot(7,2,k); k=k+1;
hg(5) = plot(t,f3);

ax(k) = subplot(7,2,k); k=k+1;
stem(fax,fftshift(abs(fft(f3))),&apos;filled&apos;)

ax(k) = subplot(7,2,k); k=k+1;
hg(6) = plot(t,f4);

ax(k) = subplot(7,2,k); k=k+1;
stem(fax,fftshift(abs(fft(f4))),&apos;filled&apos;)

ax(k) = subplot(7,2,k); k=k+1;
hg(7) = plot(t,f5);

ax(k) = subplot(7,2,k); k=k+1;
hg(8) = plot(fax,fftshift(abs(fft(f5))));

ax(k) = subplot(7,2,k); k=k+1;
stem(t,f6,&apos;filled&apos;)

ax(k) = subplot(7,2,k); k=k+1;
stem(fax,fftshift(abs(fft(f6))),&apos;filled&apos;)

ax(k) = subplot(7,2,k); k=k+1;
stem(t,f7,&apos;filled&apos;)
xtick = get(gca,&apos;XTick&apos;);
xticklabel = get(gca,&apos;XTickLabel&apos;);
xlabel(&apos;Time&apos;)

ax(k) = subplot(7,2,k); k=k+1;
stem(fax,fftshift(abs(fft(f7))),&apos;filled&apos;)
ftick = get(gca,&apos;XTick&apos;);
xlabel(&apos;Frequency&apos;)

k = k-1;
set(ax(2:2:end),&apos;XLim&apos;,[0 nyq],&apos;XTickLabel&apos;,[]);
set(ax,&apos;XTickLabel&apos;,[],&apos;Box&apos;,&apos;off&apos;,&apos;TickDir&apos;,&apos;out&apos;);
set(ax(k),&apos;XTick&apos;,[0:10:nyq],&apos;XTickLabel&apos;,num2str([0:10:nyq]&apos;))
set(ax(k-1),&apos;XTick&apos;,xtick,&apos;XTickLabel&apos;,xticklabel);
set(ax([1 3 9]),&apos;YLim&apos;,[0 1.1]);
set(ax([5 7]),&apos;YLim&apos;,[-1.1 1.1]);
set(hg,&apos;LineWidth&apos;,2);
set(ax,&apos;YTickLabel&apos;,[]);</code></pre>

<p>Summary of the pairs. </p>

<ol>
<li><p>A gaussian in time is composed of frequencies that fall off from 0 in the shape of a gaussian. This is cool! It&#8217;s also a unique property of the Gaussian! Remember that a Fourier transform is just a linear operation. The Gaussian has the special property that it has the same form (Gaussian) under any linear transformation. But the width will be different. If the Gaussian is narrow in time, it will be wide in frequency. And if it is narrow in frequency, it will be broad in time. Guess what: this is related to the uncertainty principle! If something is localized in time, it is spread out in spectrum (or energy). And vice versa.</p></li>
<li><p>A pulse has FT that is periodic under an envelope that falls off with frequency. This turns out to be the <span class="math">\(sin(\omega)/\omega\)</span> function, called <span class="math">\(sinc(\omega)\)</span>. This is very important as data that is windowed with a square envelope is going to show signs of this function. That phenomenon is called &#8220;ringing&#8221;.</p></li>
<li><p>A sine function with frequency 1 has an FT with weight only at freq=1. We&#8217;ll deal with phase in a moment. </p></li>
<li><p>Here&#8217;s the sine function with frequency 10.</p></li>
<li><p>An exponential looks a lot like an exponential: the weights fall off as 1/frequency.</p></li>
<li><p>A delta function is made by adding sinusoids of equal weight at every frequency. </p></li>
<li><p>A comb function has FT that is also a comb function at the frequency of the samples and its harmonics.</p></li>
</ol>

<p>Now for completeness, let&#8217;s repeat showing real and imaginary parts.</p>

<p>Run this as a block:</p>

<pre><code class="matlab">figure(5), clf
k = 1;
ax(k) = subplot(7,4,k);k=k+1;
plot(t,f1)

ax(k) = subplot(7,4,k);k=k+1;
a = fft(ifftshift(f1));
plot(fax,fftshift(real(a)));
ax(k) = subplot(7,4,k);k=k+1;
plot(fax,fftshift(imag(a)))
ax(k) = subplot(7,4,k);k=k+1;
plot(fax,fftshift(abs(a)))
set(ax(k-1:-1:k-3),&apos;YLim&apos;,1.1*max(abs(a))*[-1 1])
stem(fax,fftshift(abs(fft(f1))),&apos;filled&apos;)

ax(k) = subplot(7,4,k);k=k+1;
plot(t,f2)

ax(k) = subplot(7,4,k);k=k+1;
a = fft(ifftshift(f2));
plot(fax,fftshift(real(a)))
ax(k) = subplot(7,4,k);k=k+1;
plot(fax,fftshift(imag(a)))
ax(k) = subplot(7,4,k);k=k+1;
plot(fax,fftshift(abs(a)))
set(ax(k-1:-1:k-3),&apos;YLim&apos;,1.1*max(abs(a))*[-1 1])
stem(fax,fftshift(abs(fft(f2))),&apos;filled&apos;)

ax(k) = subplot(7,4,k);k=k+1;
plot(t,f3)

ax(k) = subplot(7,4,k);k=k+1;
a = fft(ifftshift(f3));
plot(fax,fftshift(real(a)))

ax(k) = subplot(7,4,k);k=k+1;
plot(fax,fftshift(imag(a)))

ax(k) = subplot(7,4,k);k=k+1;
plot(fax,fftshift(abs(a)))	
set(ax(k-1:-1:k-3),&apos;YLim&apos;,1.1*max(abs(a))*[-1 1])

ax(k) = subplot(7,4,k);k=k+1;
plot(t,f4)

ax(k) = subplot(7,4,k);k=k+1;
a = fft(ifftshift(f4));	
plot(fax,fftshift(real(a)))

ax(k) = subplot(7,4,k);k=k+1;
plot(fax,fftshift(imag(a)))

ax(k) = subplot(7,4,k);k=k+1;
plot(fax,fftshift(abs(a)))
set(ax(k-1:-1:k-3),&apos;YLim&apos;,1.1*max(abs(a))*[-1 1])

ax(k) = subplot(7,4,k);k=k+1;
plot(t,f5)

ax(k) = subplot(7,4,k);k=k+1;
a = fft(ifftshift(f5));
plot(fax,fftshift(real(a)))

ax(k) = subplot(7,4,k);k=k+1;
plot(fax,fftshift(imag(a)))

ax(k) = subplot(7,4,k);k=k+1;
plot(fax,fftshift(abs(a)))
set(ax(k-1:-1:k-3),&apos;YLim&apos;,1.1*max(abs(a))*[-1 1])

ax(k) = subplot(7,4,k);k=k+1;
plot(t,f6)

ax(k) = subplot(7,4,k);k=k+1;
a = fft(ifftshift(f6));
plot(fax,fftshift(real(a)))

ax(k) = subplot(7,4,k);k=k+1;
plot(fax,fftshift(imag(a)))

ax(k) = subplot(7,4,k);k=k+1;
plot(fax,fftshift(abs(a)))
set(ax(k-1:-1:k-3),&apos;YLim&apos;,1.1*max(abs(a))*[-1 1])

ax(k) = subplot(7,4,k);k=k+1;
plot(t,f7)
xtick = get(gca,&apos;XTick&apos;);
xlabel(&apos;Time [s]&apos;)

ax(k) = subplot(7,4,k);k=k+1;
a = fft(ifftshift(f7));

plot(fax,fftshift(real(a)))
ftick = get(gca,&apos;XTick&apos;);
xlabel(&apos;Frequency [Hz]&apos;)

ax(k) = subplot(7,4,k);k=k+1;
plot(fax,fftshift(imag(a)))
xlabel(&apos;Frequency [Hz]&apos;)

ax(k) = subplot(7,4,k);k=k+1;
plot(fax,fftshift(abs(a)))
xlabel(&apos;Frequency [Hz]&apos;)
set(ax(k-1:-1:k-3),&apos;YLim&apos;,1.1*max(abs(a))*[-1 1])

k = k-1;
set(ax(2:4:end),&apos;XLim&apos;,[-nyq nyq]);
set(ax(3:4:end),&apos;XLim&apos;,[-nyq nyq]);
set(ax(4:4:end),&apos;XLim&apos;,[-nyq nyq]);
set(ax,&apos;Box&apos;,&apos;off&apos;,&apos;TickDir&apos;,&apos;out&apos;,&apos;Xtick&apos;,[])
set(ax(k:-1:k-2),&apos;XTick&apos;,[-nyq 0 nyq])
set(ax(k:-1:k-2),&apos;XTickLabel&apos;,num2str([-nyq 0 nyq]&apos;))
set(ax(1:3:k-3),&apos;XTick&apos;,[0 .5 1],&apos;XTickLabel&apos;,[],&apos;TickDir&apos;,&apos;out&apos;)
set(ax(k-3),&apos;XTick&apos;,[0 .5 1],&apos;XTickLabel&apos;,num2str([-.5;0;.5]))
set(gcf,&apos;CurrentAxes&apos;,ax(1))
title(&apos;s(t)&apos;)	
set(gcf,&apos;CurrentAxes&apos;,ax(2))
title(&apos;Real part of FT&apos;)
set(gcf,&apos;CurrentAxes&apos;,ax(3))
title(&apos;Imaginary part of FT&apos;)	
set(gcf,&apos;CurrentAxes&apos;,ax(4))
title(&apos;Amplitude of FT&apos;)</code></pre>

<p>Pause and reflect. There are a few things to mention. </p>

<p>First, notice that the zero frequency is special. It represents the mean level: the nonsinusoidal component: the <span class="math">\(cos(0)\)</span> component. This component is always purely real.</p>

<p>Invertibility and Hermitian symmetry. The FT decomposes our signals into sums of sines and cosines. This process is invertible. We could start with the Fourier transform &#8211; a list of &#8220;intensities&#8221; at each frequency &#8211; and convert it to a list of &#8220;intensities&#8221; as a function of time. The reason we can get away with this is that when we listed our intensities in the &#8220;frequency domain,&#8221; we were careful to give two values: amplitude and phase, or cosine and sine components, or real and imaginary parts. To ensure that the process is really invertible, we also need to make sure that we have the right number of values in the transforms. Put simply, we had better represent enough frequencies in the FT so that we can reconstitute the original signal by adding together all the right sinusoids. Let&#8217;s look at how many frequencies we need to represent the time functions we&#8217;ve been dealing with. If you left <span class="math">\(dt= 0.01\)</span> alone, the answer is 100. </p>

<pre><code class="matlab">length(t)</code></pre>

<p>So all of the functions of time that we&#8217;ve considered are described by a list this long containing the weights at each time point. What about the FT? The highest frequency is the Nyquist, which is half the sampling rate. That gives us just 50 frequencies. How do we transform 100 values into just 50 frequencies? You know the answer: at each frequency we need 2 numbers, a cosine and a sine component (or amplitude and phase). Moreover, for the 0 frequency, there is just one component becuase <span class="math">\(sin(0)=0\)</span>. Since <span class="math">\(cos(0)=1\)</span>, it&#8217;s clear that the weight at freq=0 is just a constant function of time. Also, at the nyquist frequency itself, all we can have is a cosine component. To see why, recognize that we only have enough samples in time to represent alternating positive and negative values at adjacent time points. If you put a <span class="math">\(0\)</span> at <span class="math">\(t=0\)</span>, which you must for <span class="math">\(sin(t)\)</span>, then there&#8217;s nothing to alternate. Okay, cool, we&#8217;ve got two components for each of the frequencies 1 to nyquist - 1, one weight at freq=0 and one weight at freq=nyquist. That&#8217;s 100 values in the FT, which corresponds to 100 values in the time function. Perfect!</p>

<p>So what&#8217;s the deal with the negative frequencies? The frequency axis does not go from 0 to nyquist but from -nyquist to nyquist&#8211;1. Doesn&#8217;t that screw up our bookkeeping? Here&#8217;s the answer. We have only considered the Fourier transform of real valued functions of time (left column of Fig. 5). The Fourier transform returns complex numbers at each frequency, which we can think of a sine waves (imaginary part) and cosine waves (real part). In fact the Fourier transform can act on complex functions of time. Instead of a real value at each time, we could have a complex number. We may not have any use for this, but the full transform takes these 2-vectors (real and imaginary parts) and transforms them to 4 values: a real and imaginary value at two frequencies, one positive and one negative. Of course, there are half as many frequencies as there are time points. What I&#8217;m saying is that we actually had twice as many values in our time functions as we thought. We used real functions of time. The extra 100 values were zeros: the weights on the imaginary part of the signals. So the transform is 1 to 1.</p>

<p>That&#8217;s all fine and good in theory, but what we care about for most applications is the Fourier transform of real valued functions. That&#8217;s like saying that we know that the imaginary part of the functions in the left column of Fig. 5 is 0 at every time point. So, I&#8217;ll ask again, why should the FT have 200 values to represent a signal that we can describe by 100 points in time? The answer is that the FTs of real signals really can be represented with just 100 numbers, just like we said. You really don&#8217;t need both positive and negative frequencies. If I tell you the weights for one of them (e.g., +5 Hz component), you know the weights of the negative frequency (e.g., &#8211;5 Hz component). This shows up as a kind of symmetry in the graphs in Figure 5. See if you can deduce the rule from these examples.</p>

<hr />

<p>I will pose this as a homework problem. First a reminder. An even symmetric
function obeys the rule <span class="math">\(f(x) = f(-x)\)</span>. An example is <span class="math">\(cos(x)\)</span>. An odd symmetric function is one that obeys the rule <span class="math">\(f(x) = -f(-x)\)</span>. An example is <span class="math">\(sin(x)\)</span>. </p>

<p>QUESTION: Which of the seven functions in Fig. 5 are even? Which is odd? Which is neither even nor odd? What do you notice about the Fourier transforms of the even and odd symmetric functions. Answer this for the three categories: even, odd, neither even nor odd.</p>

<hr />

<h2 id="partii.convolution">Part II. Convolution</h2>

<p>One of the most important uses of the FT is for computing convolution. Convolution is an operation that looks like filtering. It takes a signal and converts it to a new signal. Usually, we can think of the new signal as a filtered version of the old one. We gain a deep intuition for the process by conceptualizing the operation in the time domain and in the frequency domain (i.e., via the fourier transform). I think this is one of the most beautiful concepts in applied math &#8211; and it comes up all the time (or often if you prefer a frequency based description!).</p>

<h3 id="ii.aconvolutioninthetimedomain.">II.A Convolution in the time domain.</h3>

<p>In this section, we spend a lot of time understanding convolution without talking about FTs. But I want you to keep FTs in the back of your mind while we do this. What you should be asking yourself is this. When filtering looks like blurring, isn&#8217;t that a lot like attenuating sharp aspects of a signal, and isn&#8217;t that a lot like attenuating high frequencies?</p>

<p>Let&#8217;s get started. Consider the simplest of all possible signals: a delta function, otherwise known as a click (if it were sound pressure as a function of time) or a line (if it were light intensity as a function of horizontal position).</p>

<pre><code class="matlab">timeOfImpulse = .1
s1 = zeros(size(t)); s1(t==timeOfImpulse)=1;
figure(1),clf,plot(t,s1)</code></pre>

<p>Consider a blurring function. Let&#8217;s start with one that you&#8217;ve grown accustomed to: exponential decay. We&#8217;ll see in a moment that this function is causal, a useful property when it comes to time-dependent functions.</p>

<pre><code class="matlab">tau = .03;       % choose a time constant
b = exp(-t/tau);
plot(t,b)
set(gca,&apos;XLim&apos;,[0 timeOfImpulse+10*tau])
xlabel(&apos;Time [out to 10\tau]&apos;)</code></pre>

<p>Please run this next step without thinking about it. It&#8217;s a trick that allows me to make some pictures easily. You can come back to this if you want to pursue the matrix version of convolution.</p>

<pre><code class="matlab">A = tril(toeplitz(b));
figure(2), clf, imagesc(A)
plot(A(:,end))</code></pre>

<h3 id="whatisconvolution">What is convolution?</h3>

<p>It is a blurring of <span class="math">\(s_1\)</span> by <span class="math">\(b\)</span>. It is a new function of time that can be thought of as a weighted sum of <span class="math">\(s_1\)</span>. It&#8217;s actually easy to see what it is by looking at the formula. </p>

<p>$$s_2(k) = \sum_d{ s_1(d) * b(k-d)}$$</p>

<p><span class="math">\(s_2\)</span> is the result of the convolution. It is a function of time, but you&#8217;ve probably noticed that the variable <span class="math">\(t\)</span> is not in the equation. Actually both <span class="math">\(k\)</span> and <span class="math">\(d\)</span> refer to time, but because we are about to shift things around time takes on several meanings. It&#8217;s actually easier to keep things straight if we keep <span class="math">\(t\)</span> out of the equation. The convolution is defined at each time, which I will denote this by <span class="math">\(k\)</span>. You will come to view <span class="math">\(k\)</span> as an offset of the blur function. The original signal remains a function of time, but we&#8217;ll use a dummy variable for time. That&#8217;s what <span class="math">\(d\)</span> stands for: we can refer to <span class="math">\(d\)</span> as &#8220;dime&#8221;. There is nothing special about <span class="math">\(s_1(d)\)</span>. It is the signal plotted as a function of &#8220;dime&#8221; instead of time. Same thing - no problem. What is <span class="math">\(b(k-d)\)</span>? It is <span class="math">\(b\)</span> reflected about the y-axis and then offset by <span class="math">\(k\)</span> time steps to the right. Here is what <span class="math">\(b(k-d)\)</span> looks like when <span class="math">\(k=0\)</span>.</p>

<pre><code class="matlab">d = t;
figure(1), clf
plot(-d,b)
xlabel(&apos;-dime&apos;)

Here is what \\(b(k-d)\\) looks like for increasing values of \\(k\\). 

figure(1),clf
ax = [];

for k = 1:10
		ax(k) = subplot(10,1,k);
		plot(t(k)-d,b)
		set(gca,&apos;XLim&apos;,[-10*tau timeOfImpulse+10*tau],&apos;Box&apos;,&apos;off&apos;)
end

xtick = get(ax(1),&apos;XTickLabel&apos;);
ytick = get(ax(1),&apos;YTickLabel&apos;);
set(ax,&apos;XTickLabel&apos;,[],&apos;YTickLabel&apos;,[]);
set(ax(k),&apos;XTickLabel&apos;,xtick,&apos;YTickLabel&apos;,ytick)
xlabel(&apos;Time [d]&apos;)
set(gcf,&apos;CurrentAxes&apos;,ax(1))
title(&apos;b(k-d) for k=1 to 10&apos;) </code></pre>

<p>It is a picture of the function reflected around the ordinate and then offset to the right by <span class="math">\(k\)</span>. Can you see this? </p>

<p>Now let&#8217;s generate the convolution, <span class="math">\(s_2(k)\)</span>, step of <span class="math">\(k\)</span> by step of <span class="math">\(k\)</span>. First look at the equation and convince yourself that there is one value of the convolution produced at each offset step. Run the animation in the next loop. You might want to put some pauses in the code. Here&#8217;s what you should see. In the top panel, <span class="math">\(s_1(d)\)</span> is shown by a stem function in red. It is just an impulse. The blur function, <span class="math">\(b(k-d)\)</span> is shown in blue. It is stepped along as <span class="math">\(k\)</span> increases. The middle panel shows the product of <span class="math">\(s_1(d)\)</span> times <span class="math">\(b(k-d)\)</span>. Notice that there is a value at each value for dummy time. The bottom plot shows the sum of the products. At each time step, <span class="math">\(k\)</span>, we get just one value. This is the convolution, <span class="math">\(s_2(k)\)</span>. You will notice that the sum is weighted by the width of the time bins. Why is this? What effect does this have on the relationship between <span class="math">\(s_1\)</span> and <span class="math">\(s_2\)</span>?</p>

<pre><code class="matlab">figure(2),clf
h = [];
h(1) = subplot(3,1,1); hold on;	
h(2) = subplot(3,1,2);
h(3) = subplot(3,1,3); hold on;
set(h,&apos;TickDir&apos;,&apos;out&apos;,&apos;Box&apos;,&apos;off&apos;)
j = min([min(find(t&gt;.1 + 10*tau)) length(t)-1])
for k = 1:j
	set(gcf,&apos;CurrentAxes&apos;,h(1))
	if k&gt;1, delete(hp), end
	stem(d,s1,&apos;r&apos;), hold on;
	hp = plot(d,flipud(A(:,end-k+1)));
   		hold off
		set(gcf,&apos;CurrentAxes&apos;, h(2))
 		s1TimesConvKernel = s1 .* flipud(A(:,end-k+1));
		stem(d,s1TimesConvKernel,&apos;filled&apos;)
		set(gcf,&apos;CurrentAxes&apos;, h(3))
   		stem(t(k),sum(s1TimesConvKernel));
    	set(h,&apos;XLim&apos;,[-.05 timeOfImpulse+10*tau])
    	set(h(2:3),&apos;YLim&apos;,[0 1])
    	set(h(3),&apos;YLim&apos;,[0 .02])
    	set(h,&apos;Box&apos;,&apos;off&apos;,&apos;TickDir&apos;,&apos;out&apos;)
    	drawnow

end</code></pre>

<p>This is the original function, a delta function or impulse, smeared out by the exponential blurring function. The technical term for smearing is filtering! What you&#8217;ve simulated is a very fine click played through a woofer or a thin voltage spike as seen through an RC filter. </p>

<p>Oh yeah, there&#8217;s an easy way to get matlab to do the convolution for you. Type <code>help conv</code> in the command window and read what it says. Here&#8217;s our friend, the impulse convolved with the exponential. Notice that the result is vector whose length is bigger than <span class="math">\(t\)</span>. </p>

<pre><code class="matlab">s2 = conv(s1, b);
figure(3),clf
hold on
stem(t,s1,&apos;r&apos;), plot(t,b,&apos;g&apos;,t,s2(1:length(t)),&apos;r--&apos;)</code></pre>

<p>Here&#8217;s the convolution between a comb function and a Guassian</p>

<pre><code class="matlab">s2 = conv(comb10,gaus1);
clf, hold on
stem(t,comb10,&apos;k&apos;),plot(t,gaus1,&apos;k&apos;,t,s2(1:length(t)),&apos;r--&apos;)</code></pre>

<p>Try playing with other functions</p>

<h3 id="ii.bconvolutionandfouriertransforms">II.B Convolution and Fourier transforms</h3>

<p>Fourier transforms make convolution easy. That&#8217;s because convolution between two functions of time, like <span class="math">\(s_1(t)\)</span> and <span class="math">\(b(t)\)</span>, is equivalent to multiplying their Fourier transforms. To be more precise, if <span class="math">\(S_1(w)\)</span> is the Fourier transform of <span class="math">\(s_1(t)\)</span> and <span class="math">\(B(w)\)</span> is the FT of <span class="math">\(b(t)\)</span>, then</p>

<pre><code class="matlab">S2(w) = S1(w) .* B(w) </code></pre>

<p>is the FT of <span class="math">\(s_2(t)\)</span>.</p>

<p>This provides a simple recipe for computing convolutions.</p>

<ol>
<li>Take the Fourier transforms of the two functions you want to convolve.</li>
<li>multiply the FTs (there&#8217;s a complex number at each frequency!).</li>
<li>Take the inverse Fourier transform.</li>
</ol>

<p>Let&#8217;s do this with the exponential blurring function and <span class="math">\(s_1\)</span>. To work with <span class="math">\(b\)</span>, I need it to be defined on the same time axis as <span class="math">\(s_1\)</span>. I&#8217;ll call it <code>newb</code></p>

<pre><code class="matlab">newb = zeros(size(t));
newb(1:length(b)) = b;</code></pre>

<p>Take the Fourier transforms</p>

<pre><code class="matlab">B = fft(newb);
S1 = fft(s1);</code></pre>

<p>Multiply them at each frequency.</p>

<pre><code class="matlab">S2 = B .* S1;</code></pre>

<p>Take the inverse Fourier transform</p>

<pre><code class="matlab">s2 = ifft(S2);</code></pre>

<p>How does <span class="math">\(s_2\)</span> look? You have already seen the Fourier transforms of the signal and exponential. So I&#8217;m just going to plot the result</p>

<pre><code class="matlab">figure(4), clf
plot(t,s2)</code></pre>

<p>Let&#8217;s illustrate with a more realistic set of functions.</p>

<pre><code class="matlab">s1 = sin(2*pi*3*t) + .33 * sin(2*pi*9*t) + .2 * sin(2.*pi*15*t);</code></pre>

<p>Corrupt this signal by adding noise</p>

<pre><code class="matlab">s1 = s1 + rand(size(s1));
S1 = fft(s1);</code></pre>

<p>You could use a different blurring function. I&#8217;ll apply a Gaussian blur. See if you can figure out what the <code>fftshift</code> is doing here.</p>

<pre><code class="matlab">g = fftshift(exp(-((t-.5)/tau).^2));
G = fft(g);
S2 = G .* S1;
s2 = ifft(S2);
figure(4), clf
subplot(3,2,1)
plot(t,s1)
subplot(3,2,2)
plot(fax, fftshift(abs(S1)));
subplot(3,2,3)
plot(t,g)
subplot(3,2,4)
plot(fax,fftshift(abs(G)))
subplot(3,2,5)
plot(t,s2)
subplot(3,2,6)
plot(fax, fftshift(abs(S2)));

return</code></pre>

<p>Additional topics. You should work on all of these. If they paid me more to teach this class, I would continue the tutorial to cover these topics. But I&#8217;ll leave them to you.</p>

<ol>
<li><p>Develop better intuitions about filters and multiplication in the freq domain. Find real world examples: muffling of a cheap speaker, resonance and timbre in musical instruments, blurring of an image by an imperfect lens.</p></li>
<li><p>What is a bode plot? What is a power spectrum?</p></li>
<li><p>What is an impulse response function? Why is it useful? If I play a click through a speaker, it comes out a little less sharp. The shape of this output function is an example of an impulse response function. What is it good for? How does it relate to what your speaker will do when you send it signals that represent music? Answer this question in terms of convolution and Fourier transforms. What are the critical assumptions in this argument (hint, there are 2 tenets to linear systems theory).</p></li>
<li><p>Filtering a signal is equivalent to attenuating frequencies. Given this idea, think about designing a filter by specifying its amplitude spectrum. What problems do you face? Why can&#8217;t you make a filter that passes a band of frequencies from 10&#8211;20 Hz but cuts out all other frequencies? (<strong>Hint1</strong>: FT pairs are symmetrical if you know <span class="math">\(f(t) \Longleftrightarrow F(\omega)\)</span> are a transform pair, then <span class="math">\(F(t) \Longleftrightarrow f(\omega)\)</span> are also transform pairs. <strong>Hint 2</strong>: apply hint 1 to the <span class="math">\(pulse(t) \Longleftrightarrow sinc(\omega)\)</span> transform pair.)</p></li>
<li><p>Sampling &amp; aliasing. Consider a signal with high frequencies in it: </p>

<pre><code class="matlab">	y = sin(2*pi*3*t) + .33 * cos(2*pi*9*t) + .2 * sin(2.*pi*15*t);  

	y = sign(cos(2*pi*27*t - pi/7));

	figure(1), plot(t,y)</code></pre>

<p>Suppose the signal is sampled not at every time point but only once every 100 msec</p>

<pre><code class="matlab">	ysampled = y .* comb10;

	plot(t,ysampled)</code></pre>

<p>Why does the sampled waveform look so crumby? Look at the FT of ysampled. Notice the amplitude at low frequencies. What are they doing there? We did not make y using low frequencies? They are &#8220;aliases&#8221;. Recall that convolution between two time-functions corresponds to multiplication between their FTs. What do you think multiplying two time functions corresponds to? With the answer to that question in mind, what is the Fourier transform of y, comb10 and what do you think you would do with these Fourier transforms to produce the Fourier transform of ysampled? Think hard about what is going on in these graphs. Why do you think this under sampling of y produces &#8220;aliasing&#8221;? What is going on in the frequency domain when you multiply y by comb10?</p></li>
</ol>

<script>var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function c(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function j(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function g(t,s){var r="";for(var q=0;q<t.childNodes.length;q++){if(t.childNodes[q].nodeType==3){var p=t.childNodes[q].nodeValue;if(s){p=p.replace(/\n/g,"")}r+=p}else{if(t.childNodes[q].nodeName=="BR"){r+="\n"}else{r+=g(t.childNodes[q])}}}if(/MSIE [678]/.test(navigator.userAgent)){r=r.replace(/\r/g,"\n")}return r}function a(s){var q=s.className.split(/\s+/);q=q.concat(s.parentNode.className.split(/\s+/));for(var p=0;p<q.length;p++){var r=q[p].replace(/^language-/,"");if(d[r]||r=="no-highlight"){return r}}}function b(p){var q=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{q.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);q.push({event:"stop",offset:t,node:s.childNodes[r]})}}}return t})(p,0);return q}function l(y,z,x){var r=0;var w="";var t=[];function u(){if(y.length&&z.length){if(y[0].offset!=z[0].offset){return(y[0].offset<z[0].offset)?y:z}else{return z[0].event=="start"?y:z}}else{return y.length?y:z}}function s(C){var D="<"+C.nodeName.toLowerCase();for(var A=0;A<C.attributes.length;A++){var B=C.attributes[A];D+=" "+B.nodeName.toLowerCase();if(B.nodeValue!=undefined&&B.nodeValue!=false&&B.nodeValue!=null){D+='="'+m(B.nodeValue)+'"'}}return D+">"}while(y.length||z.length){var v=u().splice(0,1)[0];w+=m(x.substr(r,v.offset-r));r=v.offset;if(v.event=="start"){w+=s(v.node);t.push(v.node)}else{if(v.event=="stop"){var q=t.length;do{q--;var p=t[q];w+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);t.splice(q,1);while(q<t.length){w+=s(t[q]);q++}}}}w+=x.substr(r);return w}function i(){function p(u,t,v){if(u.compiled){return}if(!v){u.bR=c(t,u.b?u.b:"\\B|\\b");if(!u.e&&!u.eW){u.e="\\B|\\b"}if(u.e){u.eR=c(t,u.e)}}if(u.i){u.iR=c(t,u.i)}if(u.r==undefined){u.r=1}if(u.k){u.lR=c(t,u.l||hljs.IR,true)}for(var s in u.k){if(!u.k.hasOwnProperty(s)){continue}if(u.k[s] instanceof Object){u.kG=u.k}else{u.kG={keyword:u.k}}break}if(!u.c){u.c=[]}u.compiled=true;for(var r=0;r<u.c.length;r++){p(u.c[r],t,false)}if(u.starts){p(u.starts,t,false)}}for(var q in d){if(!d.hasOwnProperty(q)){continue}p(d[q].dM,d[q],true)}}function e(J,D){if(!i.called){i();i.called=true}function z(r,M){for(var L=0;L<M.c.length;L++){if(M.c[L].bR.test(r)){return M.c[L]}}}function w(L,r){if(C[L].e&&C[L].eR.test(r)){return 1}if(C[L].eW){var M=w(L-1,r);return M?M+1:0}return 0}function x(r,L){return L.iR&&L.iR.test(r)}function A(O,N){var M=[];for(var L=0;L<O.c.length;L++){M.push(O.c[L].b)}var r=C.length-1;do{if(C[r].e){M.push(C[r].e)}r--}while(C[r+1].eW);if(O.i){M.push(O.i)}return c(N,"("+M.join("|")+")",true)}function s(M,L){var N=C[C.length-1];if(!N.t){N.t=A(N,H)}N.t.lastIndex=L;var r=N.t.exec(M);if(r){return[M.substr(L,r.index-L),r[0],false]}else{return[M.substr(L),"",true]}}function p(O,r){var L=H.cI?r[0].toLowerCase():r[0];for(var N in O.kG){if(!O.kG.hasOwnProperty(N)){continue}var M=O.kG[N].hasOwnProperty(L);if(M){return[N,M]}}return false}function F(M,O){if(!O.k){return m(M)}var N="";var P=0;O.lR.lastIndex=0;var L=O.lR.exec(M);while(L){N+=m(M.substr(P,L.index-P));var r=p(O,L);if(r){t+=r[1];N+='<span class="'+r[0]+'">'+m(L[0])+"</span>"}else{N+=m(L[0])}P=O.lR.lastIndex;L=O.lR.exec(M)}N+=m(M.substr(P,M.length-P));return N}function K(r,M){if(M.sL&&d[M.sL]){var L=e(M.sL,r);t+=L.keyword_count;return L.value}else{return F(r,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){q+=L;M.buffer=""}else{if(M.eB){q+=m(r)+L;M.buffer=""}else{q+=L;M.buffer=r}}C.push(M);B+=M.r}function E(O,L,Q){var R=C[C.length-1];if(Q){q+=K(R.buffer+O,R);return false}var M=z(L,R);if(M){q+=K(R.buffer+O,R);I(M,L);return M.rB}var r=w(C.length-1,L);if(r){var N=R.cN?"</span>":"";if(R.rE){q+=K(R.buffer+O,R)+N}else{if(R.eE){q+=K(R.buffer+O,R)+N+m(L)}else{q+=K(R.buffer+O+L,R)+N}}while(r>1){N=C[C.length-2].cN?"</span>":"";q+=N;r--;C.length--}var P=C[C.length-1];C.length--;C[C.length-1].buffer="";if(P.starts){I(P.starts,"")}return R.rE}if(x(L,R)){throw"Illegal"}}var H=d[J];var C=[H.dM];var B=0;var t=0;var q="";try{var v=0;H.dM.buffer="";do{var y=s(D,v);var u=E(y[0],y[1],y[2]);v+=y[0].length;if(!u){v+=y[1].length}}while(!y[2]);if(C.length>1){throw"Illegal"}return{r:B,keyword_count:t,value:q}}catch(G){if(G=="Illegal"){return{r:0,keyword_count:0,value:m(D)}}else{throw G}}}function f(t){var r={keyword_count:0,r:0,value:m(t)};var q=r;for(var p in d){if(!d.hasOwnProperty(p)){continue}var s=e(p,t);s.language=p;if(s.keyword_count+s.r>q.keyword_count+q.r){q=s}if(s.keyword_count+s.r>r.keyword_count+r.r){q=r;r=s}}if(q.language){r.second_best=q}return r}function h(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function o(u,x,q){var y=g(u,q);var s=a(u);if(s=="no-highlight"){return}if(s){var w=e(s,y)}else{var w=f(y);s=w.language}var p=b(u);if(p.length){var r=document.createElement("pre");r.innerHTML=w.value;w.value=l(p,b(r),y)}w.value=h(w.value,x,q);var t=u.className;if(!t.match("(\\s|^)(language-)?"+s+"(\\s|$)")){t=t?(t+" "+s):s}if(/MSIE [678]/.test(navigator.userAgent)&&u.tagName=="CODE"&&u.parentNode.tagName=="PRE"){var r=u.parentNode;var v=document.createElement("div");v.innerHTML="<pre><code>"+w.value+"</code></pre>";u=v.firstChild.firstChild;v.firstChild.cN=r.cN;r.parentNode.replaceChild(v.firstChild,r)}else{u.innerHTML=w.value}u.className=t;u.result={language:s,kw:w.keyword_count,re:w.r};if(w.second_best){u.second_best={language:w.second_best.language,kw:w.second_best.keyword_count,re:w.second_best.r}}}function k(){if(k.called){return}k.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=j(r[p]);if(q){o(q,hljs.tabReplace)}}}function n(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",k,false);window.addEventListener("load",k,false)}else{if(window.attachEvent){window.attachEvent("onload",k)}else{window.onload=k}}}var d={};this.LANGUAGES=d;this.highlight=e;this.highlightAuto=f;this.fixMarkup=h;this.highlightBlock=o;this.initHighlighting=k;this.initHighlightingOnLoad=n;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0x[A-Za-z0-9]+|\\d+(\\.\\d+)?)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.inherit=function(p,s){var r={};for(var q in p){r[q]=p[q]}if(s){for(var q in s){r[q]=s[q]}}return r}}();hljs.LANGUAGES.bash=function(){var d={"true":1,"false":1};var b={cN:"variable",b:"\\$([a-zA-Z0-9_]+)\\b"};var a={cN:"variable",b:"\\$\\{(([^}])|(\\\\}))+\\}",c:[hljs.CNM]};var c={cN:"string",b:'"',e:'"',i:"\\n",c:[hljs.BE,b,a],r:0};var e={cN:"test_condition",b:"",e:"",c:[c,b,a,hljs.CNM],k:{literal:d},r:0};return{dM:{k:{keyword:{"if":1,then:1,"else":1,fi:1,"for":1,"break":1,"continue":1,"while":1,"in":1,"do":1,done:1,echo:1,exit:1,"return":1,set:1,declare:1},literal:d},c:[{cN:"shebang",b:"(#!\\/bin\\/bash)|(#!\\/bin\\/sh)",r:10},hljs.HCM,hljs.CNM,c,b,a,hljs.inherit(e,{b:"\\[ ",e:" \\]",r:0}),hljs.inherit(e,{b:"\\[\\[ ",e:" \\]\\]"})]}}}();hljs.LANGUAGES.cs={dM:{k:{"abstract":1,as:1,base:1,bool:1,"break":1,"byte":1,"case":1,"catch":1,"char":1,checked:1,"class":1,"const":1,"continue":1,decimal:1,"default":1,delegate:1,"do":1,"do":1,"double":1,"else":1,"enum":1,event:1,explicit:1,extern:1,"false":1,"finally":1,fixed:1,"float":1,"for":1,foreach:1,"goto":1,"if":1,implicit:1,"in":1,"int":1,"interface":1,internal:1,is:1,lock:1,"long":1,namespace:1,"new":1,"null":1,object:1,operator:1,out:1,override:1,params:1,"private":1,"protected":1,"public":1,readonly:1,ref:1,"return":1,sbyte:1,sealed:1,"short":1,sizeof:1,stackalloc:1,"static":1,string:1,struct:1,"switch":1,"this":1,"throw":1,"true":1,"try":1,"typeof":1,uint:1,ulong:1,unchecked:1,unsafe:1,ushort:1,using:1,virtual:1,"volatile":1,"void":1,"while":1,ascending:1,descending:1,from:1,get:1,group:1,into:1,join:1,let:1,orderby:1,partial:1,select:1,set:1,value:1,"var":1,where:1,yield:1},c:[{cN:"comment",b:"///",e:"$",rB:true,c:[{cN:"xmlDocTag",b:"///|<!--|-->"},{cN:"xmlDocTag",b:"</?",e:">"}]},hljs.CLCM,hljs.CBLCLM,{cN:"string",b:'@"',e:'"',c:[{b:'""'}]},hljs.ASM,hljs.QSM,hljs.CNM]}};hljs.LANGUAGES.ruby=function(){var g="[a-zA-Z_][a-zA-Z0-9_]*(\\!|\\?)?";var a="[a-zA-Z_]\\w*[!?=]?|[-+~]\\@|<<|>>|=~|===?|<=>|[<>]=?|\\*\\*|[-/+%^&*~`|]|\\[\\]=?";var n={keyword:{and:1,"false":1,then:1,defined:1,module:1,"in":1,"return":1,redo:1,"if":1,BEGIN:1,retry:1,end:1,"for":1,"true":1,self:1,when:1,next:1,until:1,"do":1,begin:1,unless:1,END:1,rescue:1,nil:1,"else":1,"break":1,undef:1,not:1,"super":1,"class":1,"case":1,require:1,yield:1,alias:1,"while":1,ensure:1,elsif:1,or:1,def:1},keymethods:{__id__:1,__send__:1,abort:1,abs:1,"all?":1,allocate:1,ancestors:1,"any?":1,arity:1,assoc:1,at:1,at_exit:1,autoload:1,"autoload?":1,"between?":1,binding:1,binmode:1,"block_given?":1,call:1,callcc:1,caller:1,capitalize:1,"capitalize!":1,casecmp:1,"catch":1,ceil:1,center:1,chomp:1,"chomp!":1,chop:1,"chop!":1,chr:1,"class":1,class_eval:1,"class_variable_defined?":1,class_variables:1,clear:1,clone:1,close:1,close_read:1,close_write:1,"closed?":1,coerce:1,collect:1,"collect!":1,compact:1,"compact!":1,concat:1,"const_defined?":1,const_get:1,const_missing:1,const_set:1,constants:1,count:1,crypt:1,"default":1,default_proc:1,"delete":1,"delete!":1,delete_at:1,delete_if:1,detect:1,display:1,div:1,divmod:1,downcase:1,"downcase!":1,downto:1,dump:1,dup:1,each:1,each_byte:1,each_index:1,each_key:1,each_line:1,each_pair:1,each_value:1,each_with_index:1,"empty?":1,entries:1,eof:1,"eof?":1,"eql?":1,"equal?":1,"eval":1,exec:1,exit:1,"exit!":1,extend:1,fail:1,fcntl:1,fetch:1,fileno:1,fill:1,find:1,find_all:1,first:1,flatten:1,"flatten!":1,floor:1,flush:1,for_fd:1,foreach:1,fork:1,format:1,freeze:1,"frozen?":1,fsync:1,getc:1,gets:1,global_variables:1,grep:1,gsub:1,"gsub!":1,"has_key?":1,"has_value?":1,hash:1,hex:1,id:1,include:1,"include?":1,included_modules:1,index:1,indexes:1,indices:1,induced_from:1,inject:1,insert:1,inspect:1,instance_eval:1,instance_method:1,instance_methods:1,"instance_of?":1,"instance_variable_defined?":1,instance_variable_get:1,instance_variable_set:1,instance_variables:1,"integer?":1,intern:1,invert:1,ioctl:1,"is_a?":1,isatty:1,"iterator?":1,join:1,"key?":1,keys:1,"kind_of?":1,lambda:1,last:1,length:1,lineno:1,ljust:1,load:1,local_variables:1,loop:1,lstrip:1,"lstrip!":1,map:1,"map!":1,match:1,max:1,"member?":1,merge:1,"merge!":1,method:1,"method_defined?":1,method_missing:1,methods:1,min:1,module_eval:1,modulo:1,name:1,nesting:1,"new":1,next:1,"next!":1,"nil?":1,nitems:1,"nonzero?":1,object_id:1,oct:1,open:1,pack:1,partition:1,pid:1,pipe:1,pop:1,popen:1,pos:1,prec:1,prec_f:1,prec_i:1,print:1,printf:1,private_class_method:1,private_instance_methods:1,"private_method_defined?":1,private_methods:1,proc:1,protected_instance_methods:1,"protected_method_defined?":1,protected_methods:1,public_class_method:1,public_instance_methods:1,"public_method_defined?":1,public_methods:1,push:1,putc:1,puts:1,quo:1,raise:1,rand:1,rassoc:1,read:1,read_nonblock:1,readchar:1,readline:1,readlines:1,readpartial:1,rehash:1,reject:1,"reject!":1,remainder:1,reopen:1,replace:1,require:1,"respond_to?":1,reverse:1,"reverse!":1,reverse_each:1,rewind:1,rindex:1,rjust:1,round:1,rstrip:1,"rstrip!":1,scan:1,seek:1,select:1,send:1,set_trace_func:1,shift:1,singleton_method_added:1,singleton_methods:1,size:1,sleep:1,slice:1,"slice!":1,sort:1,"sort!":1,sort_by:1,split:1,sprintf:1,squeeze:1,"squeeze!":1,srand:1,stat:1,step:1,store:1,strip:1,"strip!":1,sub:1,"sub!":1,succ:1,"succ!":1,sum:1,superclass:1,swapcase:1,"swapcase!":1,sync:1,syscall:1,sysopen:1,sysread:1,sysseek:1,system:1,syswrite:1,taint:1,"tainted?":1,tell:1,test:1,"throw":1,times:1,to_a:1,to_ary:1,to_f:1,to_hash:1,to_i:1,to_int:1,to_io:1,to_proc:1,to_s:1,to_str:1,to_sym:1,tr:1,"tr!":1,tr_s:1,"tr_s!":1,trace_var:1,transpose:1,trap:1,truncate:1,"tty?":1,type:1,ungetc:1,uniq:1,"uniq!":1,unpack:1,unshift:1,untaint:1,untrace_var:1,upcase:1,"upcase!":1,update:1,upto:1,"value?":1,values:1,values_at:1,warn:1,write:1,write_nonblock:1,"zero?":1,zip:1}};var h={cN:"yardoctag",b:"@[A-Za-z]+"};var d={cN:"comment",b:"#",e:"$",c:[h]};var c={cN:"comment",b:"^\\=begin",e:"^\\=end",c:[h],r:10};var b={cN:"comment",b:"^__END__",e:"\\n$"};var u={cN:"subst",b:"#\\{",e:"}",l:g,k:n};var p=[hljs.BE,u];var s={cN:"string",b:"'",e:"'",c:p,r:0};var r={cN:"string",b:'"',e:'"',c:p,r:0};var q={cN:"string",b:"%[qw]?\\(",e:"\\)",c:p,r:10};var o={cN:"string",b:"%[qw]?\\[",e:"\\]",c:p,r:10};var m={cN:"string",b:"%[qw]?{",e:"}",c:p,r:10};var l={cN:"string",b:"%[qw]?<",e:">",c:p,r:10};var k={cN:"string",b:"%[qw]?/",e:"/",c:p,r:10};var j={cN:"string",b:"%[qw]?%",e:"%",c:p,r:10};var i={cN:"string",b:"%[qw]?-",e:"-",c:p,r:10};var t={cN:"string",b:"%[qw]?\\|",e:"\\|",c:p,r:10};var e={cN:"function",b:"\\bdef\\s+",e:" |$|;",l:g,k:n,c:[{cN:"title",b:a,l:g,k:n},{cN:"params",b:"\\(",e:"\\)",l:g,k:n},d,c,b]};var f={cN:"identifier",b:g,l:g,k:n,r:0};var v=[d,c,b,s,r,q,o,m,l,k,j,i,t,{cN:"class",b:"\\b(class|module)\\b",e:"$|;",k:{"class":1,module:1},c:[{cN:"title",b:"[A-Za-z_]\\w*(::\\w+)*(\\?|\\!)?",r:0},{cN:"inheritance",b:"<\\s*",c:[{cN:"parent",b:"("+hljs.IR+"::)?"+hljs.IR}]},d,c,b]},e,{cN:"constant",b:"(::)?([A-Z]\\w*(::)?)+",r:0},{cN:"symbol",b:":",c:[s,r,q,o,m,l,k,j,i,t,f],r:0},{cN:"number",b:"(\\b0[0-7_]+)|(\\b0x[0-9a-fA-F_]+)|(\\b[1-9][0-9_]*(\\.[0-9_]+)?)|[0_]\\b",r:0},{cN:"number",b:"\\?\\w"},{cN:"variable",b:"(\\$\\W)|((\\$|\\@\\@?)(\\w+))"},f,{b:"("+hljs.RSR+")\\s*",c:[d,c,b,{cN:"regexp",b:"/",e:"/[a-z]*",i:"\\n",c:[hljs.BE]}],r:0}];u.c=v;e.c[1].c=v;return{dM:{l:g,k:n,c:v}}}();hljs.LANGUAGES.diff={cI:true,dM:{c:[{cN:"chunk",b:"^\\@\\@ +\\-\\d+,\\d+ +\\+\\d+,\\d+ +\\@\\@$",r:10},{cN:"chunk",b:"^\\*\\*\\* +\\d+,\\d+ +\\*\\*\\*\\*$",r:10},{cN:"chunk",b:"^\\-\\-\\- +\\d+,\\d+ +\\-\\-\\-\\-$",r:10},{cN:"header",b:"Index: ",e:"$"},{cN:"header",b:"=====",e:"=====$"},{cN:"header",b:"^\\-\\-\\-",e:"$"},{cN:"header",b:"^\\*{3} ",e:"$"},{cN:"header",b:"^\\+\\+\\+",e:"$"},{cN:"header",b:"\\*{5}",e:"\\*{5}$"},{cN:"addition",b:"^\\+",e:"$"},{cN:"deletion",b:"^\\-",e:"$"},{cN:"change",b:"^\\!",e:"$"}]}};hljs.LANGUAGES.javascript={dM:{k:{keyword:{"in":1,"if":1,"for":1,"while":1,"finally":1,"var":1,"new":1,"function":1,"do":1,"return":1,"void":1,"else":1,"break":1,"catch":1,"instanceof":1,"with":1,"throw":1,"case":1,"default":1,"try":1,"this":1,"switch":1,"continue":1,"typeof":1,"delete":1},literal:{"true":1,"false":1,"null":1}},c:[hljs.ASM,hljs.QSM,hljs.CLCM,hljs.CBLCLM,hljs.CNM,{b:"("+hljs.RSR+"|case|return|throw)\\s*",k:{"return":1,"throw":1,"case":1},c:[hljs.CLCM,hljs.CBLCLM,{cN:"regexp",b:"/",e:"/[gim]*",c:[{b:"\\\\/"}]}],r:0},{cN:"function",b:"\\bfunction\\b",e:"{",k:{"function":1},c:[{cN:"title",b:"[A-Za-z$_][0-9A-Za-z$_]*"},{cN:"params",b:"\\(",e:"\\)",c:[hljs.ASM,hljs.QSM,hljs.CLCM,hljs.CBLCLM]}]}]}};hljs.LANGUAGES.css=function(){var a={cN:"function",b:hljs.IR+"\\(",e:"\\)",c:[{eW:true,eE:true,c:[hljs.NM,hljs.ASM,hljs.QSM]}]};return{cI:true,dM:{i:"[=/|']",c:[hljs.CBLCLM,{cN:"id",b:"\\#[A-Za-z0-9_-]+"},{cN:"class",b:"\\.[A-Za-z0-9_-]+",r:0},{cN:"attr_selector",b:"\\[",e:"\\]",i:"$"},{cN:"pseudo",b:":(:)?[a-zA-Z0-9\\_\\-\\+\\(\\)\\\"\\']+"},{cN:"at_rule",b:"@(font-face|page)",l:"[a-z-]+",k:{"font-face":1,page:1}},{cN:"at_rule",b:"@",e:"[{;]",eE:true,k:{"import":1,page:1,media:1,charset:1},c:[a,hljs.ASM,hljs.QSM,hljs.NM]},{cN:"tag",b:hljs.IR,r:0},{cN:"rules",b:"{",e:"}",i:"[^\\s]",r:0,c:[hljs.CBLCLM,{cN:"rule",b:"[^\\s]",rB:true,e:";",eW:true,c:[{cN:"attribute",b:"[A-Z\\_\\.\\-]+",e:":",eE:true,i:"[^\\s]",starts:{cN:"value",eW:true,eE:true,c:[a,hljs.NM,hljs.QSM,hljs.ASM,hljs.CBLCLM,{cN:"hexcolor",b:"\\#[0-9A-F]+"},{cN:"important",b:"!important"}]}}]}]}]}}}();hljs.LANGUAGES.xml=function(){var b="[A-Za-z0-9\\._:-]+";var a={eW:true,c:[{cN:"attribute",b:b,r:0},{b:'="',rB:true,e:'"',c:[{cN:"value",b:'"',eW:true}]},{b:"='",rB:true,e:"'",c:[{cN:"value",b:"'",eW:true}]},{b:"=",c:[{cN:"value",b:"[^\\s/>]+"}]}]};return{cI:true,dM:{c:[{cN:"pi",b:"<\\?",e:"\\?>",r:10},{cN:"doctype",b:"<!DOCTYPE",e:">",r:10,c:[{b:"\\[",e:"\\]"}]},{cN:"comment",b:"<!--",e:"-->",r:10},{cN:"cdata",b:"<\\!\\[CDATA\\[",e:"\\]\\]>",r:10},{cN:"tag",b:"<style",e:">",k:{title:{style:1}},c:[a],starts:{cN:"css",e:"</style>",rE:true,sL:"css"}},{cN:"tag",b:"<script",e:">",k:{title:{script:1}},c:[a],starts:{cN:"javascript",e:"<\/script>",rE:true,sL:"javascript"}},{cN:"vbscript",b:"<%",e:"%>",sL:"vbscript"},{cN:"tag",b:"</?",e:"/?>",c:[{cN:"title",b:"[^ />]+"},a]}]}}}();hljs.LANGUAGES.java={dM:{k:{"false":1,"synchronized":1,"int":1,"abstract":1,"float":1,"private":1,"char":1,"interface":1,"boolean":1,"static":1,"null":1,"if":1,"const":1,"for":1,"true":1,"while":1,"long":1,"throw":1,strictfp:1,"finally":1,"protected":1,"extends":1,"import":1,"native":1,"final":1,"implements":1,"return":1,"void":1,"enum":1,"else":1,"break":1,"transient":1,"new":1,"catch":1,"instanceof":1,"byte":1,"super":1,"class":1,"volatile":1,"case":1,assert:1,"short":1,"package":1,"default":1,"double":1,"public":1,"try":1,"this":1,"switch":1,"continue":1,"throws":1},c:[{cN:"javadoc",b:"/\\*\\*",e:"\\*/",c:[{cN:"javadoctag",b:"@[A-Za-z]+"}],r:10},hljs.CLCM,hljs.CBLCLM,hljs.ASM,hljs.QSM,{cN:"class",b:"(class |interface )",e:"{",k:{"class":1,"interface":1},i:":",c:[{b:"(implements|extends)",k:{"extends":1,"implements":1},r:10},{cN:"title",b:hljs.UIR}]},hljs.CNM,{cN:"annotation",b:"@[A-Za-z]+"}]}};hljs.LANGUAGES.php={cI:true,dM:{k:{and:1,include_once:1,list:1,"abstract":1,global:1,"private":1,echo:1,"interface":1,as:1,"static":1,endswitch:1,array:1,"null":1,"if":1,endwhile:1,or:1,"const":1,"for":1,endforeach:1,self:1,"var":1,"while":1,isset:1,"public":1,"protected":1,exit:1,foreach:1,"throw":1,elseif:1,"extends":1,include:1,__FILE__:1,empty:1,require_once:1,"function":1,"do":1,xor:1,"return":1,"implements":1,parent:1,clone:1,use:1,__CLASS__:1,__LINE__:1,"else":1,"break":1,print:1,"eval":1,"new":1,"catch":1,__METHOD__:1,"class":1,"case":1,exception:1,php_user_filter:1,"default":1,die:1,require:1,__FUNCTION__:1,enddeclare:1,"final":1,"try":1,"this":1,"switch":1,"continue":1,endfor:1,endif:1,declare:1,unset:1,"true":1,"false":1,namespace:1},c:[hljs.CLCM,hljs.HCM,{cN:"comment",b:"/\\*",e:"\\*/",c:[{cN:"phpdoc",b:"\\s@[A-Za-z]+",r:10}]},hljs.CNM,hljs.inherit(hljs.ASM,{i:null}),hljs.inherit(hljs.QSM,{i:null}),{cN:"variable",b:"\\$[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*"},{cN:"preprocessor",b:"<\\?php",r:10},{cN:"preprocessor",b:"\\?>"}]}};hljs.LANGUAGES.python=function(){var c={cN:"string",b:"(u|b)?r?'''",e:"'''",r:10};var b={cN:"string",b:'(u|b)?r?"""',e:'"""',r:10};var a={cN:"string",b:"(u|r|ur|b|br)'",e:"'",c:[hljs.BE],r:10};var f={cN:"string",b:'(u|r|ur|b|br)"',e:'"',c:[hljs.BE],r:10};var d={cN:"title",b:hljs.UIR};var e={cN:"params",b:"\\(",e:"\\)",c:[c,b,a,f,hljs.ASM,hljs.QSM]};return{dM:{k:{keyword:{and:1,elif:1,is:1,global:1,as:1,"in":1,"if":1,from:1,raise:1,"for":1,except:1,"finally":1,print:1,"import":1,pass:1,"return":1,exec:1,"else":1,"break":1,not:1,"with":1,"class":1,assert:1,yield:1,"try":1,"while":1,"continue":1,del:1,or:1,def:1,lambda:1,nonlocal:10},built_in:{None:1,True:1,False:1,Ellipsis:1,NotImplemented:1}},i:"(</|->|\\?)",c:[hljs.HCM,c,b,a,f,hljs.ASM,hljs.QSM,{cN:"function",b:"\\bdef ",e:":",i:"$",k:{def:1},c:[d,e],r:10},{cN:"class",b:"\\bclass ",e:":",i:"[${]",k:{"class":1},c:[d,e],r:10},hljs.CNM,{cN:"decorator",b:"@",e:"$"}]}}}();hljs.LANGUAGES.sql={cI:true,dM:{i:"[^\\s]",c:[{cN:"operator",b:"(begin|start|commit|rollback|savepoint|lock|alter|create|drop|rename|call|delete|do|handler|insert|load|replace|select|truncate|update|set|show|pragma)\\b",e:";|$",k:{keyword:{all:1,partial:1,global:1,month:1,current_timestamp:1,using:1,go:1,revoke:1,smallint:1,indicator:1,"end-exec":1,disconnect:1,zone:1,"with":1,character:1,assertion:1,to:1,add:1,current_user:1,usage:1,input:1,local:1,alter:1,match:1,collate:1,real:1,then:1,rollback:1,get:1,read:1,timestamp:1,session_user:1,not:1,integer:1,bit:1,unique:1,day:1,minute:1,desc:1,insert:1,execute:1,like:1,ilike:2,level:1,decimal:1,drop:1,"continue":1,isolation:1,found:1,where:1,constraints:1,domain:1,right:1,national:1,some:1,module:1,transaction:1,relative:1,second:1,connect:1,escape:1,close:1,system_user:1,"for":1,deferred:1,section:1,cast:1,current:1,sqlstate:1,allocate:1,intersect:1,deallocate:1,numeric:1,"public":1,preserve:1,full:1,"goto":1,initially:1,asc:1,no:1,key:1,output:1,collation:1,group:1,by:1,union:1,session:1,both:1,last:1,language:1,constraint:1,column:1,of:1,space:1,foreign:1,deferrable:1,prior:1,connection:1,unknown:1,action:1,commit:1,view:1,or:1,first:1,into:1,"float":1,year:1,primary:1,cascaded:1,except:1,restrict:1,set:1,references:1,names:1,table:1,outer:1,open:1,select:1,size:1,are:1,rows:1,from:1,prepare:1,distinct:1,leading:1,create:1,only:1,next:1,inner:1,authorization:1,schema:1,corresponding:1,option:1,declare:1,precision:1,immediate:1,"else":1,timezone_minute:1,external:1,varying:1,translation:1,"true":1,"case":1,exception:1,join:1,hour:1,"default":1,"double":1,scroll:1,value:1,cursor:1,descriptor:1,values:1,dec:1,fetch:1,procedure:1,"delete":1,and:1,"false":1,"int":1,is:1,describe:1,"char":1,as:1,at:1,"in":1,varchar:1,"null":1,trailing:1,any:1,absolute:1,current_time:1,end:1,grant:1,privileges:1,when:1,cross:1,check:1,write:1,current_date:1,pad:1,begin:1,temporary:1,exec:1,time:1,update:1,catalog:1,user:1,sql:1,date:1,on:1,identity:1,timezone_hour:1,natural:1,whenever:1,interval:1,work:1,order:1,cascade:1,diagnostics:1,nchar:1,having:1,left:1,call:1,"do":1,handler:1,load:1,replace:1,truncate:1,start:1,lock:1,show:1,pragma:1},aggregate:{count:1,sum:1,min:1,max:1,avg:1}},c:[{cN:"string",b:"'",e:"'",c:[hljs.BE,{b:"''"}],r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE,{b:'""'}],r:0},{cN:"string",b:"`",e:"`",c:[hljs.BE]},hljs.CNM,{b:"\\n"}]},hljs.CBLCLM,{cN:"comment",b:"--",e:"$"}]}};hljs.LANGUAGES.ini={cI:true,dM:{i:"[^\\s]",c:[{cN:"comment",b:";",e:"$"},{cN:"title",b:"^\\[",e:"\\]"},{cN:"setting",b:"^[a-z0-9_\\[\\]]+[ \\t]*=[ \\t]*",e:"$",c:[{cN:"value",eW:true,k:{on:1,off:1,"true":1,"false":1,yes:1,no:1},c:[hljs.QSM,hljs.NM]}]}]}};hljs.LANGUAGES.perl=function(){var c={getpwent:1,getservent:1,quotemeta:1,msgrcv:1,scalar:1,kill:1,dbmclose:1,undef:1,lc:1,ma:1,syswrite:1,tr:1,send:1,umask:1,sysopen:1,shmwrite:1,vec:1,qx:1,utime:1,local:1,oct:1,semctl:1,localtime:1,readpipe:1,"do":1,"return":1,format:1,read:1,sprintf:1,dbmopen:1,pop:1,getpgrp:1,not:1,getpwnam:1,rewinddir:1,qq:1,fileno:1,qw:1,endprotoent:1,wait:1,sethostent:1,bless:1,s:1,opendir:1,"continue":1,each:1,sleep:1,endgrent:1,shutdown:1,dump:1,chomp:1,connect:1,getsockname:1,die:1,socketpair:1,close:1,flock:1,exists:1,index:1,shmget:1,sub:1,"for":1,endpwent:1,redo:1,lstat:1,msgctl:1,setpgrp:1,abs:1,exit:1,select:1,print:1,ref:1,gethostbyaddr:1,unshift:1,fcntl:1,syscall:1,"goto":1,getnetbyaddr:1,join:1,gmtime:1,symlink:1,semget:1,splice:1,x:1,getpeername:1,recv:1,log:1,setsockopt:1,cos:1,last:1,reverse:1,gethostbyname:1,getgrnam:1,study:1,formline:1,endhostent:1,times:1,chop:1,length:1,gethostent:1,getnetent:1,pack:1,getprotoent:1,getservbyname:1,rand:1,mkdir:1,pos:1,chmod:1,y:1,substr:1,endnetent:1,printf:1,next:1,open:1,msgsnd:1,readdir:1,use:1,unlink:1,getsockopt:1,getpriority:1,rindex:1,wantarray:1,hex:1,system:1,getservbyport:1,endservent:1,"int":1,chr:1,untie:1,rmdir:1,prototype:1,tell:1,listen:1,fork:1,shmread:1,ucfirst:1,setprotoent:1,"else":1,sysseek:1,link:1,getgrgid:1,shmctl:1,waitpid:1,unpack:1,getnetbyname:1,reset:1,chdir:1,grep:1,split:1,require:1,caller:1,lcfirst:1,until:1,warn:1,"while":1,values:1,shift:1,telldir:1,getpwuid:1,my:1,getprotobynumber:1,"delete":1,and:1,sort:1,uc:1,defined:1,srand:1,accept:1,"package":1,seekdir:1,getprotobyname:1,semop:1,our:1,rename:1,seek:1,"if":1,q:1,chroot:1,sysread:1,setpwent:1,no:1,crypt:1,getc:1,chown:1,sqrt:1,write:1,setnetent:1,setpriority:1,foreach:1,tie:1,sin:1,msgget:1,map:1,stat:1,getlogin:1,unless:1,elsif:1,truncate:1,exec:1,keys:1,glob:1,tied:1,closedir:1,ioctl:1,socket:1,readlink:1,"eval":1,xor:1,readline:1,binmode:1,setservent:1,eof:1,ord:1,bind:1,alarm:1,pipe:1,atan2:1,getgrent:1,exp:1,time:1,push:1,setgrent:1,gt:1,lt:1,or:1,ne:1,m:1};var d={cN:"subst",b:"[$@]\\{",e:"}",k:c,r:10};var b={cN:"variable",b:"\\$\\d"};var a={cN:"variable",b:"[\\$\\%\\@\\*](\\^\\w\\b|#\\w+(\\:\\:\\w+)*|[^\\s\\w{]|{\\w+}|\\w+(\\:\\:\\w*)*)"};var g=[hljs.BE,d,b,a];var f={b:"->",c:[{b:hljs.IR},{b:"{",e:"}"}]};var e=[b,a,hljs.HCM,{cN:"comment",b:"^(__END__|__DATA__)",e:"\\n$",r:5},f,{cN:"string",b:"q[qwxr]?\\s*\\(",e:"\\)",c:g,r:5},{cN:"string",b:"q[qwxr]?\\s*\\[",e:"\\]",c:g,r:5},{cN:"string",b:"q[qwxr]?\\s*\\{",e:"\\}",c:g,r:5},{cN:"string",b:"q[qwxr]?\\s*\\|",e:"\\|",c:g,r:5},{cN:"string",b:"q[qwxr]?\\s*\\<",e:"\\>",c:g,r:5},{cN:"string",b:"qw\\s+q",e:"q",c:g,r:5},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"string",b:'"',e:'"',c:g,r:0},{cN:"string",b:"`",e:"`",c:[hljs.BE]},{cN:"string",b:"{\\w+}",r:0},{cN:"string",b:"-?\\w+\\s*\\=\\>",r:0},{cN:"number",b:"(\\b0[0-7_]+)|(\\b0x[0-9a-fA-F_]+)|(\\b[1-9][0-9_]*(\\.[0-9_]+)?)|[0_]\\b",r:0},{cN:"regexp",b:"(s|tr|y)/(\\\\.|[^/])*/(\\\\.|[^/])*/[a-z]*",r:10},{cN:"regexp",b:"(m|qr)?/",e:"/[a-z]*",c:[hljs.BE],r:0},{cN:"sub",b:"\\bsub\\b",e:"(\\s*\\(.*?\\))?[;{]",k:{sub:1},r:5},{cN:"operator",b:"-\\w\\b",r:0},{cN:"pod",b:"\\=\\w",e:"\\=cut"}];d.c=e;f.c[1].c=e;return{dM:{k:c,c:e}}}();hljs.LANGUAGES.cpp=function(){var b={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};var a={cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:b,r:10};a.c=[a];return{dM:{k:b,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'",e:"[^\\\\]'",i:"[^\\\\][^']"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},a]}}}();</script>

<script>hljs.initHighlightingOnLoad();</script>
    </div>
</body>
</html>