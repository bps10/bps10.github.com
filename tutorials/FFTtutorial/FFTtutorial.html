<!DOCTYPE html>  
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>FFTtutorial</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
/* 
   This document has been created with Marked.app <http://markedapp.com>, Copyright 2011 Brett Terpstra
   Please leave this notice in place, along with any additional credits below.
   ---------------------------------------------------------------
   Title: Swiss
   Author: Brett Terpstra
   Description: Clean, Swiss typography with no frills.
*/
body{-webkit-font-smoothing:antialiased;font:normal .8764em/1.5em Arial,Verdana,sans-serif;margin:0}html>body{font-size:13px; max-width: 800px; position: auto; margin: 2em;}li{font-size:110%}li li{font-size:100%}li p{font-size:100%;margin:.5em 0}h1{color:#000;font-size:2.2857em;line-height:.6563em;margin:.6563em 0}h2{color:#111;font-size:1.7143em;line-height:.875em;margin:.875em 0}h3{color:#111;font-size:1.5em;line-height:1em;margin:1em 0}h4{color:#111;font-size:1.2857em;line-height:1.1667em;margin:1.1667em 0}h5{color:#111;font-size:1.15em;line-height:1.3em;margin:1.3em 0}h6{font-size:1em;line-height:1.5em;margin:1.5em 0}body,p,td,div{color:#111;font-family:"Helvetica Neue",Helvetica,Arial,Verdana,sans-serif;word-wrap:break-word}h1,h2,h3,h4,h5,h6{line-height:1.5em}a{-webkit-transition:color .2s ease-in-out;color:#0d6ea1;text-decoration:none}a:hover{color:#3593d9}.footnote{color:#0d6ea1;font-size:.8em;vertical-align:super}#wrapper img{max-width:100%;height:auto}dd{margin-bottom:1em}li>p:first-child{margin:0}ul ul,ul ol{margin-bottom:.4em}caption,col,colgroup,table,tbody,td,tfoot,th,thead,tr{border-spacing:0}table{border:1px solid rgba(0,0,0,0.25);border-collapse:collapse;display:table;empty-cells:hide;margin:-1px 0 23px;padding:0;table-layout:fixed}caption{display:table-caption;font-weight:700}col{display:table-column}colgroup{display:table-column-group}tbody{display:table-row-group}tfoot{display:table-footer-group}thead{display:table-header-group}td,th{display:table-cell}tr{display:table-row}table th,table td{font-size:1.1em;line-height:23px;padding:0 1em}table thead{background:rgba(0,0,0,0.15);border:1px solid rgba(0,0,0,0.15);border-bottom:1px solid rgba(0,0,0,0.2)}table tbody{background:rgba(0,0,0,0.05)}table tfoot{background:rgba(0,0,0,0.15);border:1px solid rgba(0,0,0,0.15);border-top:1px solid rgba(0,0,0,0.2)}figure{display:inline-block;margin-bottom:1.2em;position:relative;margin:1em 0}figcaption{font-style:italic;text-align:center;background:rgba(0,0,0,.9);color:rgba(255,255,255,1);position:absolute;left:0;bottom:-24px;width:98%;padding:1%;-webkit-transition:all .2s ease-in-out}.poetry pre{display:block;font-family:Georgia,Garamond,serif!important;font-size:110%!important;font-style:italic;line-height:1.6em;margin-left:1em}.poetry pre code{font-family:Georgia,Garamond,serif!important}blockquote p{font-size:110%;font-style:italic;line-height:1.6em}sup,sub,a.footnote{font-size:1.4ex;height:0;line-height:1;position:relative;vertical-align:super}sub{vertical-align:sub;top:-1px}p,h5{font-size:1.1429em;line-height:1.3125em;margin:1.3125em 0}dt,th{font-weight:700}table tr:nth-child(odd),table th:nth-child(odd),table td:nth-child(odd){background:rgba(255,255,255,0.06)}table tr:nth-child(even),table td:nth-child(even){background:rgba(0,0,0,0.06)}@media print{body{overflow:auto}img,pre,blockquote,table,figure,p{page-break-inside:avoid}#wrapper{background:#fff;color:#303030;font-size:85%;padding:10px;position:relative;text-indent:0}}@media screen{.inverted #wrapper,.inverted{background:rgba(37,42,42,1)}.inverted hr{border-color:rgba(51,63,64,1)!important}.inverted p,.inverted td,.inverted li,.inverted h1,.inverted h2,.inverted h3,.inverted h4,.inverted h5,.inverted h6,.inverted pre,.inverted code,.inverted th,.inverted .math,.inverted caption,.inverted dd,.inverted dt{color:#eee!important}.inverted table tr:nth-child(odd),.inverted table th:nth-child(odd),.inverted table td:nth-child(odd){background:0}.inverted a{color:rgba(172,209,213,1)}#wrapper{padding:20px}::selection{background:rgba(157,193,200,.5)}h1::selection{background-color:rgba(45,156,208,.3)}h2::selection{background-color:rgba(90,182,224,.3)}h3::selection,h4::selection,h5::selection,h6::selection,li::selection,ol::selection{background-color:rgba(133,201,232,.3)}code::selection{background-color:rgba(0,0,0,.7);color:#eee}code span::selection{background-color:rgba(0,0,0,.7)!important;color:#eee!important}a::selection{background-color:rgba(255,230,102,.2)}.inverted a::selection{background-color:rgba(255,230,102,.6)}td::selection,th::selection,caption::selection{background-color:rgba(180,237,95,.5)}}/*

github.com style (c) Vasily Polovnyov <vast@whiteants.net>

*/

pre code {
  display: block; padding: 0.5em;
  color: #000;
  background: #f8f8ff
}

pre .comment,
pre .template_comment,
pre .diff .header,
pre .javadoc {
  color: #998;
  font-style: italic
}

pre .keyword,
pre .css .rule .keyword,
pre .winutils,
pre .javascript .title,
pre .lisp .title,
pre .subst {
  color: #000;
  font-weight: bold
}

pre .ruby .keyword {
  font-weight: normal
}

pre .number,
pre .hexcolor {
  color: #40a070
}

pre .string,
pre .tag .value,
pre .phpdoc,
pre .tex .formula {
  color: #d14
}

pre .title,
pre .id {
  color: #900;
  font-weight: bold
}

pre .javascript .title,
pre .lisp .title,
pre .subst {
  font-weight: normal
}

pre .class .title,
pre .haskell .label,
pre .tex .command {
  color: #458;
  font-weight: bold
}

pre .class .params {
	color: #000;
}

pre .tag,
pre .tag .title,
pre .rules .property,
pre .django .tag .keyword {
  color: #000080;
  font-weight: normal
}

pre .attribute,
pre .variable,
pre .instancevar,
pre .lisp .body {
  color: #008080
}

pre .regexp {
  color: #009926
}

pre .class {
  color: #458;
  font-weight: bold
}

pre .symbol,
pre .ruby .symbol .string,
pre .ruby .symbol .keyword,
pre .ruby .symbol .keymethods,
pre .lisp .keyword,
pre .tex .special,
pre .input_number {
  color: #0086b3
}

pre .ruby .identifier .keyword,
pre .ruby .identifier .keymethods {
  color: #0086b3;
}

pre .ruby .constant {
  color: #008080;
}

pre .builtin,
pre .built_in,
pre .lisp .title {
  color: #0086b3
}

pre .preprocessor,
pre .pi,
pre .doctype,
pre .shebang,
pre .cdata {
  color: #999;
  font-weight: bold
}

pre .deletion {
  background: #fdd
}

pre .addition {
  background: #dfd
}

pre .diff .change {
  background: #0086b3
}

pre .chunk {
  color: #aaa
}

pre .tex .formula {
  opacity: 0.5;
}
</style>

</head>
<body class="normal">
  <div id="wrapper">
      <hr />

<p>Fourier analysis tutorial for NeuBeh/PBIO 545</p>

<p>Created 1/03 Mike Shadlen</p>

<p>Revisions: 1/05 update</p>

<p>Part I revised by Adrienne Fairhall 1/06</p>

<hr />

<h1 id="introduction">| Introduction</h1>

<p>The Fourier transform is probably the most important transform in applied math. It takes a function, typically of time or space, and expresses it as a function of frequency. The goals of this tutorial are to make you comfortable with what a Fourier transform is, how to compute one, and why it is useful. We will focus on three topics: </p>

<ol>
<li>definition and properties of the Fourier transform.</li>
<li>convolution.</li>
<li>the connection between the two.</li>
</ol>

<h2 id="parti.thediscretefouriertransform">Part I. The discrete Fourier transform</h2>

<p>A transform is (usually) a reversible mapping from one set of values to another set of values. The Fourier transform takes a list of intensities at points in time (or space) and transform them to a list of &#8220;intensities&#8221; at different frequencies. Thinking about a signal as a collection of time intensities, each associated with its own time point, is simple enough. Thinking about a signal as a list of intensities, each associated with its own sinusoidal frequency, is also convenient. Perhaps because of the way our auditory system is organized, we find thinking in frequency quite natural and intuitive. You do it every day when you adjust the bass and treble on your stereo &#8211; or better yet, if you adjust knobs on an equalizer. You can imagine that describing a signal in terms of its frequencies can be convenient in certain settings. That&#8217;s what the Fourier transform is for. </p>

<p>We should emphasize from the start that taking a Fourier transform (FT, for short) does not change the signal; it just represents it differently. To be concrete, suppose there is some electrical signal that we want to describe over the phone to a friend. We could list the voltages at each time or we could list the amplitudes and phases of each of the frequencies that comprise the signal. It&#8217;s the same signal, just a different list of numbers. Sometimes it is much faster and simpler to use one type of description than the other.</p>

<p>Often, when we describe signals, we don&#8217;t think of them as lists of numbers but rather as functions of time. Of course, the function can be viewed as a way to generate a list of values at each time point. We can also use a function to describe the list of &#8220;intensities&#8221; at each frequency in a Fourier transform. The two functions are called Fourier transform pairs. For example, suppose $s(t)$ is some function of time (it has a value at each time point). And suppose that you could describe the same signal by &#8220;intensities&#8221; of frequency, $w$, using a function, $S(w)$. Then, we say that $s(t)$ and $S(w)$ are a Fourier transform pair. Or we say that $S(w)$ is the Fourier transform of $s(t)$, or that $s(t)$ is the inverse Fourier transform of $S(w)$. When we started by saying that a transform is a reversible mapping, what this means is that $S(w)$ is the unique Fourier transform of $s(t)$ and $s(t)$ is the unique inverse transform of $S(w)$.</p>

<p>Our goal here is both to help you to get comfortable with the meaning of the Fourier transform, and to get you used to using the numerical function FFT (fast Fourier transform) in Matlab. If you get everything about what that Matlab function returns to you, you&#8217;ll pretty much have mastered what you need to know.</p>

<p>Before we look at FTs, let&#8217;s get comfortable with a few illustrative functions. Since we&#8217;ll be doing everything numerically in this tutorial, we will focus here on discrete functions. What is meant by this is that we are going to make the argument of the function, say time, take discrete values. We&#8217;re used to thinking of time t occupying some continuous interval on the real number line, but here we&#8217;ll be thinking of time as integers, multiplied by some constant or scaling factor. In fact this is overwhelmingly going to be the case whenever you are thinking about real data: the values are always sampled at some particular finite sampling rate. </p>

<pre><code>clear all
</code></pre>

<p>Define a discrete time axis. The spacing is d$t$</p>

<pre><code>dt = .01;       
</code></pre>

<p>our units are seconds. So each integer time point is scaled to represent d$t$ sec</p>

<pre><code>tmax = 1

t = [0:dt:tmax-dt]';
</code></pre>

<p>Notice that we are sampling time at a rate of 1/d$t$. This will be important later.</p>

<pre><code>samplingRate = 1/dt    % in Hz
</code></pre>

<p>Think of a discrete function as a series of weights at each of the points in $t$. Let&#8217;s look at some functions this way. Here&#8217;s a gaussian profile centered at .5</p>

<pre><code>f1 = exp(-.5*(t-.5).^2 / (.05)^2);

figure(1),clf,hold on
h = plot(t,f1)
xlabel('Time [s]')
ylabel('Amplitude')
</code></pre>

<p>Pause here. The function is drawn continuously: there are no gaps. That&#8217;s because Matlab drew a line, or interpolated, between the values at the discrete time points. In reality, what we know about the function is just a bunch of heights at each of the time points. We can use the stem function to highlight this fact.</p>

<pre><code>stem(t,f1,'filled');
</code></pre>

<p>and we can toggle the smooth curve off</p>

<pre><code>set(h,'Visible','off')
</code></pre>

<p>Now&#8230; that&#8217;s a discrete function. Each of the points can be thought of as a weight given to the basis set of discrete time points. We represent the function as a list of these weights. Indeed, f1 is a vector.</p>

<pre><code>size(f1)
</code></pre>

<p>Let&#8217;s remember this function by calling it something mnemonic</p>

<pre><code>gaus1 = f1;
</code></pre>

<p>Let&#8217;s look at a few more functions</p>

<pre><code>% pulse

f2 = zeros(size(t));
f2(t&gt;.45 & t&lt;= 0.55) = 1;

figure(1), hold off
stem(t,f2,'filled')
xlabel('Time [s]')
ylabel('Amplitude')
pulse1 = f2;

% sinewaves

f3 = sin(2*pi*1*(t-.5));
sin1 = f3;
stem(t,f3,'filled')

f4 = cos(2*pi*10*(t-.5));
cos10 = f4;
stem(t,f4,'filled')

% This looks a lot better interpolated!

plot(t,f4)

% the sum (I'm not giving this a function name)

sos = .5*f3 + f4;
plot(t,sos)

% exponential

tau = .1
f5 = exp(-(t-.5)/tau);
f5(t&lt;.5) = 0;
exp1 = f5;
stem(t,f5,'filled')

% discrete delta function -- take special note of this one. 

f6 = zeros(size(t));
f6(min(find(t&gt;=.5))) = 1;
stem(t,f6,'filled')
delt1 = f6;


% comb(.1t) function. This is a sampling function or strobe function that turns on at a rate    % of 10 times per second (10 Hz). But it is also a sum of discrete delta functions.

f7 = mod(t,.1)==0;
comb10 = f7;
f7 = double(f7);

stem(t,comb10,'filled')
</code></pre>

<h4 id="reflectionpoint.">Reflection point.</h4>

<p>You have yet to see a Fourier transform. You are supposed to simply marvel at the idea of discreteness. And here is the one thing extra that you need to think about. All of the functions above can be thought of as sums of discrete delta functions with appropriately chosen weights. The most obvious example is the comb function, as we have already noted. But all the functions are just values at discrete time points. So all can be thought of as sums of delta functions. In fact, a discrete function is exactly this: the multiplication of a continuous function by comb(d*t), where d is the gap between samples (i.e., the reciprocal of the sampling rate). We will return to this point later.</p>

<p>Another important point to make before moving on. Let&#8217;s recall the idea of a BASIS SET from linear algebra. As you know, a coordinate frame is a set of vectors which span a given space: e.g. in the plane, we have an x-axis, and a y-axis. So to say that a point in the plane is (3,2) means that our vector contains 3 units along the x-axis, and 2 units along the y-axis. </p>

<p>A functional basis set is just a coordinate set for the space of functions. What does this mean? Let&#8217;s take some arbitrary data sequence, a bunch of values from time zero to time $T$. Since it is discretized, we have $N$ points in our data: a value for at each time, $0, dt, 2dt, 3dt,.. (N - 1)dt$. Let&#8217;s now think about this data as an $N$-dimensional vector, and plot it as a single point in an N-dimensional space. What is the coordinate system in which we have plotted our function? The unit vectors are the set of delta functions at each time, $t = i dt$, for $i$ ranging from $0$ to $N-1$. So axis one means how strong was the function at time $t = 0$, axis 2 is how strong the function was at time $t = dt$, and so on. If we write these as vectors they will look just like Euclidean coordinate axes: $[1 0 0 0 0 0 ...], [0 1 0 0 0 ...]$, etc. Remember that an important property of many useful coordinate systems is that the axes are orthogonal: the $x$ vector has exactly zero projection onto the $y$ vector; the dot product of the $x$ vector with the $y$ vector is zero. Similarly for our delta function coordinate system. The delta function at time $t$ is independent of the delta function at time $t'$ if $t$ is not the same as $t'$ the dot product of these two functions is zero. As we said already, any function can be written in this &#8220;time&#8221; basis by summing up weighted delta functions.</p>

<p>Now, let&#8217;s move onto Fourier transforms. We had better start by defining it. As we&#8217;ve said, calling it a transform already gives away something important. The function or data we&#8217;re describing is not changed; it&#8217;s just expressed differently. Just like when you rotate something &#8211;you don&#8217;t change the structure of the thing you rotated. </p>

<p>So now, instead of thinking of the function as a list of weights at the discrete time samples, we would now like to think of it as a list of &#8220;weights&#8221; on sinusoids. In other words, since the time representation was just one choice of coordinate systems, we can just as well represent our data function, or N-dimensional point, in some other coordinate system. The Fourier transform is a method for representing our data in another set of axes, where the axes are sines and cosines rather than delta functions. </p>

<p>This is done in a way that will need a little unpacking. Let&#8217;s look at the definition of the Fourier transform $F(\omega)$ of a continuous function $f(t)$:</p>

<p>$$F(\omega) = \frac{1}{\sqrt{2\pi}} f(t) \exp( - i \omega t)dt$$</p>

<p>The integral here is the equivalent for a continuous function of a dot product or projection. So the idea is that we project our data function against the basis function $exp(-i \omega t)$, where $\omega$ is frequency; one basis function for every value of $\omega$. So how is this sines and cosines? Remember back to the olden days when you first met complex numbers. Remember Euler&#8217;s identity:</p>

<p>$$exp( i x) = cos(x) + i * sin(x)$$ </p>

<p>Let&#8217;s have a look at some examples:</p>

<pre><code>exp(i*0.5)
exp(i*pi)
exp(i*-pi)
exp(i*pi/2)
</code></pre>

<p>All of these are complex numbers, but with different real and imaginary parts. (If the above didn&#8217;t give you back a complex number, try </p>

<pre><code>clear i
</code></pre>

<p>in case you have redefined &#8220;i&#8221; somehow as a real number.)</p>

<p>I included some particular cases where the real or the imaginary part is zero. So what is this i thing? It&#8217;s telling you that this is really a two-component number, with two &#8220;axes&#8221;, the &#8220;real&#8221; axis and the &#8220;imaginary&#8221; axis, where the length of the number $exp(i x)$ along the real axis is $cos(x)$, and its length along the imaginary axis is $sin(x)$. We could write it in vector notation as ($cos(x)$, $sin(x)$) and plot it as a point on a plane. The length of the vector is 1, since </p>

<p>$$cos^2(x) + sin^2(x) = 1$$</p>

<p>If we want a longer vector, we scale the whole thing by some amplitude $A: A exp( i x)$. The value of $x$ is the phase in radians.</p>

<p>So: every complex number is really 2-dimensional, and every $exp(- i \omega t)$ for a given $\omega$ will give us two components, one real, corresponding to the cosine at frequency $\omega$, and one imaginary, corresponding to the sine. This is just an elegant way to capture the issue that for every frequency, we need two values. Why? Because every frequency component is specified both by an AMPLITUDE and a PHASE. Using both a sine and a cosine component allows us to construct any arbitrary phase. Remember another fact from your dim dark past: the sin identities. Do you remember:</p>

<p>$$sin (x+y) = sin(x) cos(y) + sin(y) cos(x)$$</p>

<p>so let&#8217;s say $x$ is $t$ and $y$ is some phase $p$. then $a sin (t + p) = a * cos(p)*sin(t) + a * sin(p)cos(t)$, where $a * cos(p)$ and $a * sin(p)$ now become the coefficients of the sine and cosine functions. Again, the total amplitude is $a * \sqrt(sin(p)^2 + cos(p)^2) = a$ (!) So representing phase as well as overall amplitude is why you need both a sine and a cosine at every frequency. Using complex numbers for each frequency is just a way to do this neatly and elegantly.</p>

<p>Let&#8217;s see that in action. Let&#8217;s look at the real and imaginary parts of the function $exp(i \omega t)$, for $\omega = 2 \pi$. (this frequency is angular frequency! here we will generally take out the $2 \pi$ factor, $\omega = 2 \pi f$, and work in hertz..)</p>

<pre><code>figure(2), clf
subplot(2,1,1); plot(t,real(exp(i*2*pi*t))); xlabel('t'); title('Real part of exp(iwt)')
subplot(2,1,2); plot(t,imag(exp(i*2*pi*t))); xlabel('t'); title('Imaginary part of exp(iwt)')
</code></pre>

<p>Let&#8217;s also look at a fun demo showing how you shift the phase of a sine or cosine function by multiplying by $exp(i \phi)$, where $\phi$ is the phase. Below the graph you&#8217;ll see the polar representation of $exp(i \phi)$.</p>

<pre><code>figure(4), clf
clear ax
ax(1) = subplot(3,1,1);
ax(2) = subplot(2,3,5);
axis square

phi = [0:.01:2*pi]';  % take phase shifts going right around the circle.
polar(phi,ones(size(phi)));
polar([0 0],[0,1])
set(gcf,'CurrentAxes',ax(1))
plot(t,cos(2*pi*t))
set(gcf,'CurrentAxes',ax(2))
nsteps = 100;        %  change this to alter the speed of the demo

for j = 1:nsteps
    phi = j* 2*pi/nsteps;   % we are incrementing the phase shift
    set(gcf,'CurrentAxes',ax(1))
    plot(t,real(exp(i*(2*pi*t + phi))),'r','LineWidth',3)

    set(gcf,'CurrentAxes',ax(2))
    polar([0 phi],[0 1],'r'),hold on
    polar([0 0 phi],[0 cos(phi) 1],'k--'), hold off

    pause
    drawnow

end
</code></pre>

<p>So what&#8217;s the upshot: by projecting onto $exp(i \omega t)$, we are actually projecting against both a sine and a cosine function of frequency $\omega$. Remember that a sine, or any other function, is just a linear sum of the delta functions so this is just a linear transformation. Even better, since sines and cosines of different frequencies are orthogonal, the sines and cosines form an orthogonal basis set. The sines and cosines are not the only functions that we could choose for our alternative basis set, but they are useful so often that the Fourier transform is one of the most commonly used of all possibilities. When we study dimensionality reduction, we will talk about some other alternatives.</p>

<p>Let&#8217;s look at some examples.</p>

<p>Let&#8217;s start with a cosine function. What do you expect to see? Let&#8217;s bung the cosine function into Matlab&#8217;s function fft and plot. I will use a frequency $f$ of 10 Hz. Worth mentioning now that in the above we have used the symbol $\omega$, omega, which is the angular frequency. Frequency in Hz is related to angular frequency by a factor of $2 \pi$, $\omega = 2 \pi f$, which is often useful to factor out. </p>

<pre><code>y = cos(2*pi*10*t);

figure(2), clf
subplot(1,2,1)
plot(t,y)
xlabel('Time')

subplot(1,2,2)
fcos = fft(y);
plot(fcos); ylabel('Fourier transform of cosine function')
</code></pre>

<p>What the *$&amp;#^? (pardon my Australian.)
Let&#8217;s see what you have plotted.</p>

<pre><code>whos fcos
</code></pre>

<p>Ah ha. The fft of y is, of course, a complex array, so has a real and imaginary part. When you use plot, matlab plots the real part vs the imaginary part. So let&#8217;s plot each of the two parts separately.</p>

<pre><code>subplot(1,2,1); 
plot(real(fcos));
ylabel('Real part of fft(cos t)');
subplot(1,2,2); 
plot(imag(fcos));
ylabel('Imaginary part of ft(cos t)');
</code></pre>

<p>Now we&#8217;re getting somewhere. The real part has two big spikes; the imaginary part is tiny, really just zero except for numerical noise. Now, why and where are those two big spikes? We put in a 100-dimensional purely real data vector, and got out a 100-dimensional complex vector, meaning 200 values. That seems to be twice as many as we need. We&#8217;ll talk more about this later. We have obtained a function of frequency, but what are the labels on the frequency axis? </p>

<p>Let&#8217;s recall yet another high school fact: how do you write a cosine in terms of complex numbers? It&#8217;s just a rewriting of the definition (known as the Euler identity) we used above. </p>

<p>Remember: </p>

<p>$$cos(a) = \frac{exp(ia) + exp(-ia)}{2}$$</p>

<p>Similarly, </p>

<p>$$sin(a) = \frac{exp(ia) - exp(-ia)}{2i}$$</p>

<p>Our transform scans over $\omega$ (or $f$), looking for nonzero values. Under the integral sign, we have</p>

<p>$$exp(i w t)*exp(i 2 \pi 10 t) + exp( -i 2 \pi 10 t)= exp(i (w - 2 \pi 10) t) + exp(i(w + 2 \pi 10) t)$$</p>

<p>The integral of an imaginary exponential turns out to be zero unless what is in the exponent exactly cancels, giving you exp(0) = 1. This happens for the first term at $\omega = 2 \pi 10$, and for the second term at $\omega = - 2 \pi 10$.</p>

<p>So, we expect two peaks for our transform, at $f = 10$ and at $f = -10$. </p>

<p>Why do the peaks show up in the output array at index 10 and 90? It turns, out that the negative frequencies are arranged after the positive ones. The ordering runs 0 through to max frequency $W$, then from $-W$ to -min frequency. From now on, we&#8217;ll use the Matlab function &#8220;fftshift&#8221; to rearrange them in the usual increasing order. </p>

<p>Let&#8217;s have a look at the transform of a sine wave as well: (note here I&#8217;m switching to a plotting form more appropriate for this kind of spiky function, and I&#8217;m scaling the y axes of the real and imaginary parts by the same amount so we don&#8217;t see all that $10^{-13}$ stuff)</p>

<pre><code>clf;
subplot(2,2,1); 
stem(fftshift(real(fcos)),'filled');
ylabel('Real part of ft(cos)');

subplot(2,2,2); 
stem(fftshift(imag(fcos)),'filled');
ylabel('Imaginary part of ft(cos)');

y = sin(2*pi*10*t);
subplot(2,2,3)
fsin = fft(y);

subplot(2,2,3); 
stem(fftshift(real(fsin)),'filled');
ylabel('Real part of ft(sin)');

subplot(2,2,4); 
stem(fftshift(imag(fsin)),'filled');
ylabel('Imaginary part of ft(sin)');
</code></pre>

<p>Just as we should now expect: the large values are in the imaginary part, because of that i in the definition of sine, and include a positive and a negative peak, because of the sign difference between the exponents.</p>

<p>Did you expect that the $+f$ component would come out with a negative sign? Why?</p>

<p>This is a good moment to think what exactly the minimum and maximum frequencies are. The lowest frequency is determined by the length of the sample. If the sample is of length $T$, then the lowest frequency that can be resolved is $\frac{1}{T}$. How about the highest frequency? If the sampling rate is d$t$, then you cannot specify any frequency higher than $1/dt$. That is because you need at least 2 points to capture an oscillation, one on the up part and one on the down part. This frequency is called the NYQUIST frequency. The Nyquist frequency says that you must sample at least twice as often as the shortest wavelength in your data. In class we&#8217;ll try to look at what happens if your signal contains frequencies higher than your sampling rate.</p>

<p>OK, so let&#8217;s define our frequency axis.</p>

<pre><code>nyq = samplingRate/2;
dw = 1/tmax;
fax = -nyq: dw: nyq-dw;
</code></pre>

<p>and now finally plot, </p>

<pre><code>clf;
subplot(2,2,1); 
stem(fax,fftshift(real(fcos)),'filled');
set(gca,'YLim',[-50 50])
ylabel('Real part of ft(cos wt)');
xlabel('Frequency')

subplot(2,2,2); 
stem(fax,fftshift(imag(fcos)),'filled');
set(gca,'YLim',[-50 50])
ylabel('Imaginary part of ft(cos wt)');
xlabel('Frequency')

y = sin(2*pi*10*t);
subplot(2,2,3)
fsin = fft(y);

subplot(2,2,3); 
stem(fax,fftshift(real(fsin)),'filled');
set(gca,'YLim',[-50 50])
ylabel('Real part of ft(sin wt)');
xlabel('Frequency')

subplot(2,2,4); 
stem(fax,fftshift(imag(fsin)),'filled');
set(gca,'YLim',[-50 50])
ylabel('Imaginary part of ft(sin wt)');
xlabel('Frequency')
</code></pre>

<p>OK, let&#8217;s stretch our wings a bit and try some other functions.</p>

<p>A sum of 3 sinusoids!</p>

<pre><code>y = sin(2*pi*3*t) + .33 * sin(2*pi*9*t) + .2 * sin(2.*pi*15*t); 
figure(3), clf
subplot(2,2,1)
plot(t,y)
xlabel('Time')

subplot(2,2,2)
stem(fax,fftshift(imag(fft(y))),'filled')
xlabel('Frequency')
</code></pre>

<p>Notice that the time function is almost square wave like. Its definition makes it crystal clear that it is a sum of three sinusoids. This is pretty easy to see in the Fourier transform. We only plotted the imaginary part as we now know that sines will only give us nonzero imaginary part.</p>

<p>Now let&#8217;s look at each of the functions we&#8217;ve talked about already. For ease of viewing, I will plot some of the time functions with lines that interpolate between the (time or frequency) points. For some functions, I use the stem command to emphasize the discreteness. First, let&#8217;s just plot the overall amplitude (the absolute value of the complex number).</p>

<pre><code>figure(3), clf
k = 1;
ax(k) = subplot(7,2,k); k=k+1;
hg(1) = plot(t,f1);

ax(k) = subplot(7,2,k); k=k+1;
hg(2) = plot(fax,fftshift(abs(fft(f1))));
stem(fax,fftshift(abs(fft(f1))),'filled')

ax(k) = subplot(7,2,k); k=k+1;
hg(3) = plot(t,f2);

ax(k) = subplot(7,2,k); k=k+1;
hg(4) = plot(fax,fftshift(abs(fft(f2))));
stem(fax,fftshift(abs(fft(f2))),'filled')

ax(k) = subplot(7,2,k); k=k+1;
hg(5) = plot(t,f3);

ax(k) = subplot(7,2,k); k=k+1;
stem(fax,fftshift(abs(fft(f3))),'filled')

ax(k) = subplot(7,2,k); k=k+1;
hg(6) = plot(t,f4);

ax(k) = subplot(7,2,k); k=k+1;
stem(fax,fftshift(abs(fft(f4))),'filled')

ax(k) = subplot(7,2,k); k=k+1;
hg(7) = plot(t,f5);

ax(k) = subplot(7,2,k); k=k+1;
hg(8) = plot(fax,fftshift(abs(fft(f5))));

ax(k) = subplot(7,2,k); k=k+1;
stem(t,f6,'filled')

ax(k) = subplot(7,2,k); k=k+1;
stem(fax,fftshift(abs(fft(f6))),'filled')

ax(k) = subplot(7,2,k); k=k+1;
stem(t,f7,'filled')
xtick = get(gca,'XTick');
xticklabel = get(gca,'XTickLabel');
xlabel('Time')

ax(k) = subplot(7,2,k); k=k+1;
stem(fax,fftshift(abs(fft(f7))),'filled')
ftick = get(gca,'XTick');
xlabel('Frequency')

k = k-1;
set(ax(2:2:end),'XLim',[0 nyq],'XTickLabel',[]);
set(ax,'XTickLabel',[],'Box','off','TickDir','out');
set(ax(k),'XTick',[0:10:nyq],'XTickLabel',num2str([0:10:nyq]'))
set(ax(k-1),'XTick',xtick,'XTickLabel',xticklabel);
set(ax([1 3 9]),'YLim',[0 1.1]);
set(ax([5 7]),'YLim',[-1.1 1.1]);
set(hg,'LineWidth',2);
set(ax,'YTickLabel',[]);
</code></pre>

<p>Summary of the pairs. </p>

<ol>
<li><p>A gaussian in time is composed of frequencies that fall off from 0 in the shape of a gaussian. This is cool! It&#8217;s also a unique property of the Gaussian! Remember that a Fourier transform is just a linear operation. The Gaussian has the special property that it has the same form (Gaussian) under any linear transformation. But the width will be different. If the Gaussian is narrow in time, it will be wide in frequency. And if it is narrow in frequency, it will be broad in time. Guess what: this is related to the uncertainty principle! If something is localized in time, it is spread out in spectrum (or energy). And vice versa.</p></li>
<li><p>A pulse has FT that is periodic under an envelope that falls off with frequency. This turns out to be the $sin(\omega)/\omega$ function, called $sinc(\omega)$. This is very important as data that is windowed with a square envelope is going to show signs of this function. That phenomenon is called &#8220;ringing&#8221;.</p></li>
<li><p>A sine function with frequency 1 has an FT with weight only at freq=1. We&#8217;ll deal with phase in a moment. </p></li>
<li><p>Here&#8217;s the sine function with frequency 10.</p></li>
<li><p>An exponential looks a lot like an exponential; the weights fall off as 1/frequency.</p></li>
<li><p>A delta function is made by adding sinusoids of equal weight at every frequency. </p></li>
<li><p>A comb function has FT that is also a comb function at the frequency of the samples and its harmonics.</p></li>
</ol>

<p>Now for completeness, let&#8217;s repeat showing real and imaginary parts.</p>

<p>Run this as a block:</p>

<pre><code>figure(5), clf
k = 1;
ax(k) = subplot(7,4,k);k=k+1;
plot(t,f1)

ax(k) = subplot(7,4,k);k=k+1;
a = fft(ifftshift(f1));
plot(fax,fftshift(real(a)));
ax(k) = subplot(7,4,k);k=k+1;
plot(fax,fftshift(imag(a)))
ax(k) = subplot(7,4,k);k=k+1;
plot(fax,fftshift(abs(a)))
set(ax(k-1:-1:k-3),'YLim',1.1*max(abs(a))*[-1 1])
stem(fax,fftshift(abs(fft(f1))),'filled')

ax(k) = subplot(7,4,k);k=k+1;
plot(t,f2)

ax(k) = subplot(7,4,k);k=k+1;
a = fft(ifftshift(f2));
plot(fax,fftshift(real(a)))
ax(k) = subplot(7,4,k);k=k+1;
plot(fax,fftshift(imag(a)))
ax(k) = subplot(7,4,k);k=k+1;
plot(fax,fftshift(abs(a)))
set(ax(k-1:-1:k-3),'YLim',1.1*max(abs(a))*[-1 1])
stem(fax,fftshift(abs(fft(f2))),'filled')

ax(k) = subplot(7,4,k);k=k+1;
plot(t,f3)

ax(k) = subplot(7,4,k);k=k+1;
a = fft(ifftshift(f3));
plot(fax,fftshift(real(a)))

ax(k) = subplot(7,4,k);k=k+1;
plot(fax,fftshift(imag(a)))

ax(k) = subplot(7,4,k);k=k+1;
plot(fax,fftshift(abs(a)))  
set(ax(k-1:-1:k-3),'YLim',1.1*max(abs(a))*[-1 1])

ax(k) = subplot(7,4,k);k=k+1;
plot(t,f4)

ax(k) = subplot(7,4,k);k=k+1;
a = fft(ifftshift(f4)); 
plot(fax,fftshift(real(a)))

ax(k) = subplot(7,4,k);k=k+1;
plot(fax,fftshift(imag(a)))

ax(k) = subplot(7,4,k);k=k+1;
plot(fax,fftshift(abs(a)))
set(ax(k-1:-1:k-3),'YLim',1.1*max(abs(a))*[-1 1])

ax(k) = subplot(7,4,k);k=k+1;
plot(t,f5)

ax(k) = subplot(7,4,k);k=k+1;
a = fft(ifftshift(f5));
plot(fax,fftshift(real(a)))

ax(k) = subplot(7,4,k);k=k+1;
plot(fax,fftshift(imag(a)))

ax(k) = subplot(7,4,k);k=k+1;
plot(fax,fftshift(abs(a)))
set(ax(k-1:-1:k-3),'YLim',1.1*max(abs(a))*[-1 1])

ax(k) = subplot(7,4,k);k=k+1;
plot(t,f6)

ax(k) = subplot(7,4,k);k=k+1;
a = fft(ifftshift(f6));
plot(fax,fftshift(real(a)))

ax(k) = subplot(7,4,k);k=k+1;
plot(fax,fftshift(imag(a)))

ax(k) = subplot(7,4,k);k=k+1;
plot(fax,fftshift(abs(a)))
set(ax(k-1:-1:k-3),'YLim',1.1*max(abs(a))*[-1 1])

ax(k) = subplot(7,4,k);k=k+1;
plot(t,f7)
xtick = get(gca,'XTick');
xlabel('Time [s]')

ax(k) = subplot(7,4,k);k=k+1;
a = fft(ifftshift(f7));

plot(fax,fftshift(real(a)))
ftick = get(gca,'XTick');
xlabel('Frequency [Hz]')

ax(k) = subplot(7,4,k);k=k+1;
plot(fax,fftshift(imag(a)))
xlabel('Frequency [Hz]')

ax(k) = subplot(7,4,k);k=k+1;
plot(fax,fftshift(abs(a)))
xlabel('Frequency [Hz]')
set(ax(k-1:-1:k-3),'YLim',1.1*max(abs(a))*[-1 1])

k = k-1;
set(ax(2:4:end),'XLim',[-nyq nyq]);
set(ax(3:4:end),'XLim',[-nyq nyq]);
set(ax(4:4:end),'XLim',[-nyq nyq]);
set(ax,'Box','off','TickDir','out','Xtick',[])
set(ax(k:-1:k-2),'XTick',[-nyq 0 nyq])
set(ax(k:-1:k-2),'XTickLabel',num2str([-nyq 0 nyq]'))
set(ax(1:3:k-3),'XTick',[0 .5 1],'XTickLabel',[],'TickDir','out')
set(ax(k-3),'XTick',[0 .5 1],'XTickLabel',num2str([-.5;0;.5]))
set(gcf,'CurrentAxes',ax(1))
title('s(t)')   
set(gcf,'CurrentAxes',ax(2))
title('Real part of FT')
set(gcf,'CurrentAxes',ax(3))
title('Imaginary part of FT')   
set(gcf,'CurrentAxes',ax(4))
title('Amplitude of FT')
</code></pre>

<p>Pause and reflect. There are a few things to mention. </p>

<p>First, notice that the zero frequency is special. It represents the mean level: the nonsinusoidal component: the $cos(0)$ component. This component is always purely real.</p>

<h4>Invertibility and Hermitian symmetry. </h4>
<p>The FT decomposes our signals into sums of sines and cosines. This process is invertible. We could start with the Fourier transform &#8211; a list of &#8220;intensities&#8221; at each frequency &#8211; and convert it to a list of &#8220;intensities&#8221; as a function of time. The reason we can get away with this is that when we listed our intensities in the &#8220;frequency domain,&#8221; we were careful to give two values: amplitude and phase, or cosine and sine components, or real and imaginary parts. To ensure that the process is really invertible, we also need to make sure that we have the right number of values in the transforms. Put simply, we had better represent enough frequencies in the FT so that we can reconstitute the original signal by adding together all the right sinusoids. Let&#8217;s look at how many frequencies we need to represent the time functions we&#8217;ve been dealing with. If you left dt= 0.01 alone, the answer is 100. </p>

<pre><code>length(t)
</code></pre>

<p>So all of the functions of time that we&#8217;ve considered are described by a list this long containing the weights at each time point. What about the FT? The highest frequency is the Nyquist, which is half the sampling rate. That gives us just 50 frequencies. How do we transform 100 values into just 50 frequencies? You know the answer: at each frequency we need 2 numbers, a cosine and a sine component (or amplitude and phase). Moreover, for the 0 frequency, there is just one component becuase $sin(0)=0$. Since $cos(0)=1$, it&#8217;s clear that the weight at freq=0 is just a constant function of time. Also, at the nyquist frequency itself, all we can have is a cosine component. To see why, recognize that we only have enough samples in time to represent alternating positive and negative values at adjacent time points. If you put a $0$ at $t=0$, which you must for $sin(t)$, then there&#8217;s nothing to alternate. Okay, cool, we&#8217;ve got two components for each of the frequencies 1 to nyquist&#8211;1, one weight at freq=0 and one weight at freq=nyquist. That&#8217;s 100 values in the FT, which corresponds to 100 values in the time function. Perfect!</p>

<p>So what&#8217;s the deal with the negative frequencies? The frequency axis does not go from 0 to nyquist but from -nyquist to nyquist&#8211;1. Doesn&#8217;t that screw up our bookkeeping? Here&#8217;s the answer. We have only considered the Fourier transform of real valued functions of time (left column of Fig. 5). The Fourier transform returns complex numbers at each frequency, which we can think of a sine waves (imaginary part) and cosine waves (real part). In fact the Fourier transform can act on complex functions of time. Instead of a real value at each time, we could have a complex number. We may not have any use for this, but the full transform takes these 2-vectors (real and imaginary parts) and transforms them to 4 values: a real and imaginary value at two frequencies, one positive and one negative. Of course, there are half as many frequencies as there are time points. What I&#8217;m saying is that we actually had twice as many values in our time functions as we thought. We used real functions of time. The extra 100 values were zeros: the weights on the imaginary part of the signals. So the transform is 1 to 1.</p>

<p>That&#8217;s all fine and good in theory, but what we care about for most applications is the Fourier transform of real valued functions. That&#8217;s like saying that we know that the imaginary part of the functions in the left column of Fig. 5 is 0 at every time point. So, I&#8217;ll ask again, why should the FT have 200 values to represent a signal that we can describe by 100 points in time? The answer is that the FTs of real signals really can be represented with just 100 numbers, just like we said. You really don&#8217;t need both positive and negative frequencies. If I tell you the weights for one of them (e.g., +5 Hz component), you know the weights of the negative frequency (e.g., &#8211;5 Hz component). This shows up as a kind of symmetry in the graphs in Figure 5. See if you can deduce the rule from these examples.</p>
<hr />
<p>I will pose this as a homework problem. First a reminder. An even symmetric
function obeys the rule $f(x) = f(-x)$. An example is $cos(x)$. An odd symmetric function is one that obeys the rule $f(x) = -f(-x)$. An example is $sin(x)$. </p>

<p><b>QUESTION:</b> Which of the seven functions in Fig. 5 are even? Which is odd? Which is neither even nor odd? What do you notice about the Fourier transforms of the even and odd symmetric functions. Answer this for the three categories: even, odd, neither even nor odd.</p>
<hr />
<h2 id="partii.convolution">Part II. Convolution</h2>

<p>One of the most important uses of the FT is for computing convolution. Convolution is an operation that looks like filtering. It takes a signal and converts it to a new signal. Usually, we can think of the new signal as a filtered version of the old one. We gain a deep intuition for the process by conceptualizing the operation in the time domain and in the frequency domain (i.e., via the Fourier transform). I think this is one of the most beautiful concepts in applied math &#8211; and it comes up all the time (or often if you prefer a frequency based description!).</p>

<h3 id="ii.aconvolutioninthetimedomain.">II.A Convolution in the time domain.</h3>

<p>In this section, we spend a lot of time understanding convolution without talking about FTs. But I want you to keep FTs in the back of your mind while we do this. What you should be asking yourself is this. When filtering looks like blurring, isn&#8217;t that a lot like attenuating sharp aspects of a signal, and isn&#8217;t that a lot like attenuating high frequencies?</p>

<p>Let&#8217;s get started. Consider the simplest of all possible signals: a delta function, otherwise known as a click (if it were sound pressure as a function of time) or a line (if it were light intensity as a function of horizontal position).</p>

<pre><code>timeOfImpulse = .1
s1 = zeros(size(t)); s1(t==timeOfImpulse)=1;
figure(1),clf,plot(t,s1)
</code></pre>

<p>Consider a blurring function. Let&#8217;s start with one that you&#8217;ve grown accustomed to: eponential decay. We&#8217;ll see in a moment that this function is causal, a useful property when it comes to time-dependent functions.</p>

<pre><code>tau = .03;       % choose a time constant
b = exp(-t/tau);
plot(t,b)
set(gca,'XLim',[0 timeOfImpulse+10*tau])
xlabel('Time [out to 10\tau]')
</code></pre>

<p>Please run this next step without thinking about it. It&#8217;s a trick that allows me to make some pictures easily. You can come back to this if you want to pursue the matrix version of convolution.</p>

<pre><code>A = tril(toeplitz(b));
figure(2), clf, imagesc(A)
plot(A(:,end))
</code></pre>

<h3 id="whatisconvolution">What is convolution?</h3>

<p>It is a blurring of $s1$ by $b$. It is a new function of time that can be thought of as a weighted sum of $s1$. It&#8217;s actually easy to see what it is by looking at the formula. </p>

<p>$s2(k) = \sum_d{\prod s1(d) * b(k-d)}$</p>

<p>$s2$ is the result of the convolution. It is a function of time, but you&#8217;ve probably noticed that the variable $t$ is not in the equation. Actually both $k$ and $d$ refer to time, but because we are about to shift things around time takes on several meanings. It&#8217;s actually easier to keep things straight if we keep $t$ out of the equation. The convolution is defined at each time, which I will denote this by $k$. You will come to view $k$ as an offset of the blur function. The original signal remains a function of time, but we&#8217;ll use a dummy variable for time. That&#8217;s what $d$ stands for: we can refer to $d$ as &#8220;dime&#8221;. There is nothing special about $s1(d)$. It is the signal plotted as a function of &#8220;dime&#8221; instead of time. Same thing &#8211; no problem. What is $b(k-d)$? It is $b$ reflected about the y-axis and then offset by $k$ time steps to the right. Here is what $b(k-d)$ looks like when $k=0$.</p>

<pre><code>d = t;
figure(1), clf
plot(-d,b)
xlabel('-dime')
</code></pre>

<p>Here is what $b(k-d)$ looks like for increasing values of $k$. </p>

<pre><code>figure(1),clf
ax = [];

for k = 1:10
        ax(k) = subplot(10,1,k);
        plot(t(k)-d,b)
        set(gca,'XLim',[-10*tau timeOfImpulse+10*tau],'Box','off')
end

xtick = get(ax(1),'XTickLabel');
ytick = get(ax(1),'YTickLabel');
set(ax,'XTickLabel',[],'YTickLabel',[]);
set(ax(k),'XTickLabel',xtick,'YTickLabel',ytick)
xlabel('Time [d]')
set(gcf,'CurrentAxes',ax(1))
title('b(k-d) for k=1 to 10') 
</code></pre>

<p>It is a picture of the function reflected around the ordinate and then offet to the right by $k$. Can you see this? </p>

<p>Now let&#8217;s generate the convolution, $s2(k)$, step of $k$ by step of $k$. First look at the equation and convince yourself that there is one value of the convolution produced at each offset step. Run the animation in the next loop. You might want to put some pauses in the code. Here&#8217;s what you should see. In the top panel, $s1(d)$ is shown by a stem function in red. It is just an impulse. The blur function, $b(k-d)$ is shown in blue. It is stepped along as $k$ increases. The middle panel shows the product of $s1(d)$ times $b(k-d)$. Notice that there is a value at each value for dummy time. The bottom plot shows the sum of the products. At each time step, $k$, we get just one value. This is the convolution, $s2(k)$. You will notice that the sum is weighted by the width of the time bins. Why is this? What effect does this have on the relationship between $s1$ and $s2$?</p>

<pre><code>figure(2),clf
h = [];
h(1) = subplot(3,1,1); hold on; 
h(2) = subplot(3,1,2);
h(3) = subplot(3,1,3); hold on;
set(h,'TickDir','out','Box','off')
j = min([min(find(t&gt;.1 + 10*tau)) length(t)-1])
for k = 1:j
    set(gcf,'CurrentAxes',h(1))
    if k&gt;1, delete(hp), end
    stem(d,s1,'r'), hold on;
    hp = plot(d,flipud(A(:,end-k+1)));
        hold off
        set(gcf,'CurrentAxes', h(2))
        s1TimesConvKernel = s1 .* flipud(A(:,end-k+1));
        stem(d,s1TimesConvKernel,'filled')
        set(gcf,'CurrentAxes', h(3))
        stem(t(k),sum(s1TimesConvKernel));
        set(h,'XLim',[-.05 timeOfImpulse+10*tau])
        set(h(2:3),'YLim',[0 1])
        set(h(3),'YLim',[0 .02])
        set(h,'Box','off','TickDir','out')
        drawnow

end
</code></pre>

<p>This is the original function, a delta function or impulse, smeared out by the exponential blurring function. The technical term for smearing is filtering! What you&#8217;ve simulated is a very fine click played through a woofer or a thin voltage spike as seen through an RC filter. </p>

<p>Oh yeah, there&#8217;s an easy way to get Matlab to do the convolution for you. Type &#8216;help conv&#8217; in the command window and read what it says. Here&#8217;s our friend, the impulse convolved with the exponential. Notice that the result is vector whose length is bigger than $t$. </p>

<pre><code>s2 = conv(s1, b);
figure(3),clf
hold on
stem(t,s1,'r'), plot(t,b,'g',t,s2(1:length(t)),'r--')
</code></pre>

<p>Here&#8217;s the convolution between a comb function and a guassian</p>

<pre><code>s2 = conv(comb10,gaus1);
clf, hold on
stem(t,comb10,'k'),plot(t,gaus1,'k',t,s2(1:length(t)),'r--')
</code></pre>

<p>Try playing with other functions</p>

<h3 id="ii.bconvolutionandfouriertransforms">II.B Convolution and Fourier transforms</h3>

<p>Fourier transforms make convolution easy. That&#8217;s because convolution between two functions of time, like $s1(t)$ and $b(t)$, is equivalent to multiplying their fourier transforms. To be more precise, if $S1(w)$ is the fourier transform of $s1(t)$ and $B(w)$ is the FT of $b(t)$, then</p>

<pre><code>S2(w) = S1(w) .* B(w) 
</code></pre>

<p>is the FT of $s2(t)$.</p>

<p>This provides a simple recipe for computing convolutions:
<ol>
<li>Take the Fourier transforms of the two functions you want to convolve.</li>
<li>Multiply the FTs (there&#8217;s a complex number at each frequency!).</li>
<li>Take the inverse Fourier transform.</li>
</ol>


<p>Let&#8217;s do this with the exponential blurring function and $s1$. To work with $b$, I need it to be defined on the same time axis as $s1$. I&#8217;ll call it newb.</p>

<pre><code>newb = zeros(size(t));
newb(1:length(b)) = b;
</code></pre>

<p>Take the fourier transforms</p>

<pre><code>B = fft(newb);
S1 = fft(s1);
</code></pre>

<p>Multiply them at each frequency.</p>

<pre><code>S2 = B .* S1;
</code></pre>

<p>Take the inverse fourier transform</p>

<pre><code>s2 = ifft(S2);
</code></pre>

<p>How does $s2$ look? You have already seen the Fourier transforms of the signal and exponential. So I&#8217;m just going to plot the result</p>

<pre><code>figure(4), clf
plot(t,s2)
</code></pre>

<p>Let&#8217;s illustrate with a more realistic set of functions.</p>

<pre><code>s1 = sin(2*pi*3*t) + .33 * sin(2*pi*9*t) + .2 * sin(2.*pi*15*t);
</code></pre>

<p>Corrupt this signal by adding noise</p>

<pre><code>s1 = s1 + rand(size(s1));
S1 = fft(s1);
</code></pre>

<p>You could use a different blurring function. I&#8217;ll apply a gaussian blur. See if you can figure out what the fftshift is doing here.</p>

<pre><code>g = fftshift(exp(-((t-.5)/tau).^2));
G = fft(g);
S2 = G .* S1;
s2 = ifft(S2);
figure(4), clf
subplot(3,2,1)
plot(t,s1)
subplot(3,2,2)
plot(fax, fftshift(abs(S1)));
subplot(3,2,3)
plot(t,g)
subplot(3,2,4)
plot(fax,fftshift(abs(G)))
subplot(3,2,5)
plot(t,s2)
subplot(3,2,6)
plot(fax, fftshift(abs(S2)));

return
</code></pre>
<hr />
<p>Additional topics. You should work on all of these. If they paid me more to teach this class, I would continue the tutorial to cover these topics. But I&#8217;ll leave them to you.</p>

<ol>
<li><p>Develop better intuitions about filters and multiplication in the freq domain. Find real world examples: muffling of a cheap speaker, resonance and timbre in musical instruments, blurring of an image by an imperfect lens. </p></li>
<li><p>What is a bode plot? What is a power spectrum?</p></li>
<li><p>What is an impulse response function? Why is it useful? If I play a click through a speaker, it comes out a little less sharp. The shape of this output function is an example of an impulse response function. What is it good for? How does it relate to what your speaker will do when you send it signals that represent music? Answer this question in terms of convolution and Fourier transforms. What are the critical assumptions in this argument (hint, there are 2 tenets to linear systems theory). </p></li>
<li><p>Filtering a signal is equivalent to attenuating frequencies. Given this idea, think about designing a filter by specifying its amplitude spectrum. What problems do you face? Why can&#8217;t you make a filter that passes a band of frequencies from 10&#8211;20 Hz but cuts out all other frequencies? (<em>Hint1</em>: FT pairs are symmetrical if you know $f(t) \Longleftrightarrow F(\omega)$ are a transform pair, then $F(t) \Longleftrightarrow f(\omega)$ are also transform pairs. <em>Hint 2</em>: apply hint 1 to the $pulse(t) \Longleftrightarrow sinc(\omega)$ transform pair.)</p></li>
<li><p>Sampling &amp; aliasing. Consider a signal with high frequencies in it: </p>

<pre><code>y = sin(2*pi*3*t) + .33 * cos(2*pi*9*t) + .2 * sin(2.*pi*15*t);  

y = sign(cos(2*pi*27*t - pi/7));

figure(1), plot(t,y)
</code></pre>

<p>Suppose the signal is sampled not at every time point but only once every 100 msec</p>

<pre><code>ysampled = y .* comb10;

plot(t,ysampled)
</code></pre>
<p>Why does the sampled waveform look so crummy? Look at the FT of ysampled. Notice the amplitude at low frequencies. What are they doing there? We did not make y using low frequencies? They are &#8220;aliases&#8221;. Recall that convolution between two time-functions corresponds to multiplication between their FTs. What do you think multiplying two time functions corresponds to? With the answer to that question in mind, what is the Fourier transform of y, comb10 and what do you think you would do with these Fourier transforms to produce the Fourier transform of ysampled? Think hard about what is going on in these graphs. Why do you think this under sampling of y produces &#8220;aliasing&#8221;? What is going on in the frequency domain when you multiply y by comb10?</p></li>
</ol>

<hr />
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js">
        MathJax.Hub.Config({
            config: ["MMLorHTML.js"],
            extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js"],
            jax: ["input/TeX"],
            tex2jax: {
                inlineMath: [ ['$','$'], ["\\(","\\)"] ],
                displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
                processEscapes: false
            },
            TeX: {
                TagSide: "right",
                TagIndent: ".8em",
                MultLineWidth: "85%",
                equationNumbers: {
                   autoNumber: "AMS",
                },
                unicode: {
                   fonts: "STIXGeneral,'Arial Unicode MS'" 
                }
            },
            showProcessingMessages: false
        });
    </script>

<script>var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function c(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function j(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function g(t,s){var r="";for(var q=0;q<t.childNodes.length;q++){if(t.childNodes[q].nodeType==3){var p=t.childNodes[q].nodeValue;if(s){p=p.replace(/\n/g,"")}r+=p}else{if(t.childNodes[q].nodeName=="BR"){r+="\n"}else{r+=g(t.childNodes[q])}}}if(/MSIE [678]/.test(navigator.userAgent)){r=r.replace(/\r/g,"\n")}return r}function a(s){var q=s.className.split(/\s+/);q=q.concat(s.parentNode.className.split(/\s+/));for(var p=0;p<q.length;p++){var r=q[p].replace(/^language-/,"");if(d[r]||r=="no-highlight"){return r}}}function b(p){var q=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{q.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);q.push({event:"stop",offset:t,node:s.childNodes[r]})}}}return t})(p,0);return q}function l(y,z,x){var r=0;var w="";var t=[];function u(){if(y.length&&z.length){if(y[0].offset!=z[0].offset){return(y[0].offset<z[0].offset)?y:z}else{return z[0].event=="start"?y:z}}else{return y.length?y:z}}function s(C){var D="<"+C.nodeName.toLowerCase();for(var A=0;A<C.attributes.length;A++){var B=C.attributes[A];D+=" "+B.nodeName.toLowerCase();if(B.nodeValue!=undefined&&B.nodeValue!=false&&B.nodeValue!=null){D+='="'+m(B.nodeValue)+'"'}}return D+">"}while(y.length||z.length){var v=u().splice(0,1)[0];w+=m(x.substr(r,v.offset-r));r=v.offset;if(v.event=="start"){w+=s(v.node);t.push(v.node)}else{if(v.event=="stop"){var q=t.length;do{q--;var p=t[q];w+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);t.splice(q,1);while(q<t.length){w+=s(t[q]);q++}}}}w+=x.substr(r);return w}function i(){function p(u,t,v){if(u.compiled){return}if(!v){u.bR=c(t,u.b?u.b:"\\B|\\b");if(!u.e&&!u.eW){u.e="\\B|\\b"}if(u.e){u.eR=c(t,u.e)}}if(u.i){u.iR=c(t,u.i)}if(u.r==undefined){u.r=1}if(u.k){u.lR=c(t,u.l||hljs.IR,true)}for(var s in u.k){if(!u.k.hasOwnProperty(s)){continue}if(u.k[s] instanceof Object){u.kG=u.k}else{u.kG={keyword:u.k}}break}if(!u.c){u.c=[]}u.compiled=true;for(var r=0;r<u.c.length;r++){p(u.c[r],t,false)}if(u.starts){p(u.starts,t,false)}}for(var q in d){if(!d.hasOwnProperty(q)){continue}p(d[q].dM,d[q],true)}}function e(J,D){if(!i.called){i();i.called=true}function z(r,M){for(var L=0;L<M.c.length;L++){if(M.c[L].bR.test(r)){return M.c[L]}}}function w(L,r){if(C[L].e&&C[L].eR.test(r)){return 1}if(C[L].eW){var M=w(L-1,r);return M?M+1:0}return 0}function x(r,L){return L.iR&&L.iR.test(r)}function A(O,N){var M=[];for(var L=0;L<O.c.length;L++){M.push(O.c[L].b)}var r=C.length-1;do{if(C[r].e){M.push(C[r].e)}r--}while(C[r+1].eW);if(O.i){M.push(O.i)}return c(N,"("+M.join("|")+")",true)}function s(M,L){var N=C[C.length-1];if(!N.t){N.t=A(N,H)}N.t.lastIndex=L;var r=N.t.exec(M);if(r){return[M.substr(L,r.index-L),r[0],false]}else{return[M.substr(L),"",true]}}function p(O,r){var L=H.cI?r[0].toLowerCase():r[0];for(var N in O.kG){if(!O.kG.hasOwnProperty(N)){continue}var M=O.kG[N].hasOwnProperty(L);if(M){return[N,M]}}return false}function F(M,O){if(!O.k){return m(M)}var N="";var P=0;O.lR.lastIndex=0;var L=O.lR.exec(M);while(L){N+=m(M.substr(P,L.index-P));var r=p(O,L);if(r){t+=r[1];N+='<span class="'+r[0]+'">'+m(L[0])+"</span>"}else{N+=m(L[0])}P=O.lR.lastIndex;L=O.lR.exec(M)}N+=m(M.substr(P,M.length-P));return N}function K(r,M){if(M.sL&&d[M.sL]){var L=e(M.sL,r);t+=L.keyword_count;return L.value}else{return F(r,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){q+=L;M.buffer=""}else{if(M.eB){q+=m(r)+L;M.buffer=""}else{q+=L;M.buffer=r}}C.push(M);B+=M.r}function E(O,L,Q){var R=C[C.length-1];if(Q){q+=K(R.buffer+O,R);return false}var M=z(L,R);if(M){q+=K(R.buffer+O,R);I(M,L);return M.rB}var r=w(C.length-1,L);if(r){var N=R.cN?"</span>":"";if(R.rE){q+=K(R.buffer+O,R)+N}else{if(R.eE){q+=K(R.buffer+O,R)+N+m(L)}else{q+=K(R.buffer+O+L,R)+N}}while(r>1){N=C[C.length-2].cN?"</span>":"";q+=N;r--;C.length--}var P=C[C.length-1];C.length--;C[C.length-1].buffer="";if(P.starts){I(P.starts,"")}return R.rE}if(x(L,R)){throw"Illegal"}}var H=d[J];var C=[H.dM];var B=0;var t=0;var q="";try{var v=0;H.dM.buffer="";do{var y=s(D,v);var u=E(y[0],y[1],y[2]);v+=y[0].length;if(!u){v+=y[1].length}}while(!y[2]);if(C.length>1){throw"Illegal"}return{r:B,keyword_count:t,value:q}}catch(G){if(G=="Illegal"){return{r:0,keyword_count:0,value:m(D)}}else{throw G}}}function f(t){var r={keyword_count:0,r:0,value:m(t)};var q=r;for(var p in d){if(!d.hasOwnProperty(p)){continue}var s=e(p,t);s.language=p;if(s.keyword_count+s.r>q.keyword_count+q.r){q=s}if(s.keyword_count+s.r>r.keyword_count+r.r){q=r;r=s}}if(q.language){r.second_best=q}return r}function h(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function o(u,x,q){var y=g(u,q);var s=a(u);if(s=="no-highlight"){return}if(s){var w=e(s,y)}else{var w=f(y);s=w.language}var p=b(u);if(p.length){var r=document.createElement("pre");r.innerHTML=w.value;w.value=l(p,b(r),y)}w.value=h(w.value,x,q);var t=u.className;if(!t.match("(\\s|^)(language-)?"+s+"(\\s|$)")){t=t?(t+" "+s):s}if(/MSIE [678]/.test(navigator.userAgent)&&u.tagName=="CODE"&&u.parentNode.tagName=="PRE"){var r=u.parentNode;var v=document.createElement("div");v.innerHTML="<pre><code>"+w.value+"</code></pre>";u=v.firstChild.firstChild;v.firstChild.cN=r.cN;r.parentNode.replaceChild(v.firstChild,r)}else{u.innerHTML=w.value}u.className=t;u.result={language:s,kw:w.keyword_count,re:w.r};if(w.second_best){u.second_best={language:w.second_best.language,kw:w.second_best.keyword_count,re:w.second_best.r}}}function k(){if(k.called){return}k.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=j(r[p]);if(q){o(q,hljs.tabReplace)}}}function n(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",k,false);window.addEventListener("load",k,false)}else{if(window.attachEvent){window.attachEvent("onload",k)}else{window.onload=k}}}var d={};this.LANGUAGES=d;this.highlight=e;this.highlightAuto=f;this.fixMarkup=h;this.highlightBlock=o;this.initHighlighting=k;this.initHighlightingOnLoad=n;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0x[A-Za-z0-9]+|\\d+(\\.\\d+)?)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.inherit=function(p,s){var r={};for(var q in p){r[q]=p[q]}if(s){for(var q in s){r[q]=s[q]}}return r}}();hljs.LANGUAGES.bash=function(){var d={"true":1,"false":1};var b={cN:"variable",b:"\\$([a-zA-Z0-9_]+)\\b"};var a={cN:"variable",b:"\\$\\{(([^}])|(\\\\}))+\\}",c:[hljs.CNM]};var c={cN:"string",b:'"',e:'"',i:"\\n",c:[hljs.BE,b,a],r:0};var e={cN:"test_condition",b:"",e:"",c:[c,b,a,hljs.CNM],k:{literal:d},r:0};return{dM:{k:{keyword:{"if":1,then:1,"else":1,fi:1,"for":1,"break":1,"continue":1,"while":1,"in":1,"do":1,done:1,echo:1,exit:1,"return":1,set:1,declare:1},literal:d},c:[{cN:"shebang",b:"(#!\\/bin\\/bash)|(#!\\/bin\\/sh)",r:10},hljs.HCM,hljs.CNM,c,b,a,hljs.inherit(e,{b:"\\[ ",e:" \\]",r:0}),hljs.inherit(e,{b:"\\[\\[ ",e:" \\]\\]"})]}}}();hljs.LANGUAGES.cs={dM:{k:{"abstract":1,as:1,base:1,bool:1,"break":1,"byte":1,"case":1,"catch":1,"char":1,checked:1,"class":1,"const":1,"continue":1,decimal:1,"default":1,delegate:1,"do":1,"do":1,"double":1,"else":1,"enum":1,event:1,explicit:1,extern:1,"false":1,"finally":1,fixed:1,"float":1,"for":1,foreach:1,"goto":1,"if":1,implicit:1,"in":1,"int":1,"interface":1,internal:1,is:1,lock:1,"long":1,namespace:1,"new":1,"null":1,object:1,operator:1,out:1,override:1,params:1,"private":1,"protected":1,"public":1,readonly:1,ref:1,"return":1,sbyte:1,sealed:1,"short":1,sizeof:1,stackalloc:1,"static":1,string:1,struct:1,"switch":1,"this":1,"throw":1,"true":1,"try":1,"typeof":1,uint:1,ulong:1,unchecked:1,unsafe:1,ushort:1,using:1,virtual:1,"volatile":1,"void":1,"while":1,ascending:1,descending:1,from:1,get:1,group:1,into:1,join:1,let:1,orderby:1,partial:1,select:1,set:1,value:1,"var":1,where:1,yield:1},c:[{cN:"comment",b:"///",e:"$",rB:true,c:[{cN:"xmlDocTag",b:"///|<!--|-->"},{cN:"xmlDocTag",b:"</?",e:">"}]},hljs.CLCM,hljs.CBLCLM,{cN:"string",b:'@"',e:'"',c:[{b:'""'}]},hljs.ASM,hljs.QSM,hljs.CNM]}};hljs.LANGUAGES.ruby=function(){var g="[a-zA-Z_][a-zA-Z0-9_]*(\\!|\\?)?";var a="[a-zA-Z_]\\w*[!?=]?|[-+~]\\@|<<|>>|=~|===?|<=>|[<>]=?|\\*\\*|[-/+%^&*~`|]|\\[\\]=?";var n={keyword:{and:1,"false":1,then:1,defined:1,module:1,"in":1,"return":1,redo:1,"if":1,BEGIN:1,retry:1,end:1,"for":1,"true":1,self:1,when:1,next:1,until:1,"do":1,begin:1,unless:1,END:1,rescue:1,nil:1,"else":1,"break":1,undef:1,not:1,"super":1,"class":1,"case":1,require:1,yield:1,alias:1,"while":1,ensure:1,elsif:1,or:1,def:1},keymethods:{__id__:1,__send__:1,abort:1,abs:1,"all?":1,allocate:1,ancestors:1,"any?":1,arity:1,assoc:1,at:1,at_exit:1,autoload:1,"autoload?":1,"between?":1,binding:1,binmode:1,"block_given?":1,call:1,callcc:1,caller:1,capitalize:1,"capitalize!":1,casecmp:1,"catch":1,ceil:1,center:1,chomp:1,"chomp!":1,chop:1,"chop!":1,chr:1,"class":1,class_eval:1,"class_variable_defined?":1,class_variables:1,clear:1,clone:1,close:1,close_read:1,close_write:1,"closed?":1,coerce:1,collect:1,"collect!":1,compact:1,"compact!":1,concat:1,"const_defined?":1,const_get:1,const_missing:1,const_set:1,constants:1,count:1,crypt:1,"default":1,default_proc:1,"delete":1,"delete!":1,delete_at:1,delete_if:1,detect:1,display:1,div:1,divmod:1,downcase:1,"downcase!":1,downto:1,dump:1,dup:1,each:1,each_byte:1,each_index:1,each_key:1,each_line:1,each_pair:1,each_value:1,each_with_index:1,"empty?":1,entries:1,eof:1,"eof?":1,"eql?":1,"equal?":1,"eval":1,exec:1,exit:1,"exit!":1,extend:1,fail:1,fcntl:1,fetch:1,fileno:1,fill:1,find:1,find_all:1,first:1,flatten:1,"flatten!":1,floor:1,flush:1,for_fd:1,foreach:1,fork:1,format:1,freeze:1,"frozen?":1,fsync:1,getc:1,gets:1,global_variables:1,grep:1,gsub:1,"gsub!":1,"has_key?":1,"has_value?":1,hash:1,hex:1,id:1,include:1,"include?":1,included_modules:1,index:1,indexes:1,indices:1,induced_from:1,inject:1,insert:1,inspect:1,instance_eval:1,instance_method:1,instance_methods:1,"instance_of?":1,"instance_variable_defined?":1,instance_variable_get:1,instance_variable_set:1,instance_variables:1,"integer?":1,intern:1,invert:1,ioctl:1,"is_a?":1,isatty:1,"iterator?":1,join:1,"key?":1,keys:1,"kind_of?":1,lambda:1,last:1,length:1,lineno:1,ljust:1,load:1,local_variables:1,loop:1,lstrip:1,"lstrip!":1,map:1,"map!":1,match:1,max:1,"member?":1,merge:1,"merge!":1,method:1,"method_defined?":1,method_missing:1,methods:1,min:1,module_eval:1,modulo:1,name:1,nesting:1,"new":1,next:1,"next!":1,"nil?":1,nitems:1,"nonzero?":1,object_id:1,oct:1,open:1,pack:1,partition:1,pid:1,pipe:1,pop:1,popen:1,pos:1,prec:1,prec_f:1,prec_i:1,print:1,printf:1,private_class_method:1,private_instance_methods:1,"private_method_defined?":1,private_methods:1,proc:1,protected_instance_methods:1,"protected_method_defined?":1,protected_methods:1,public_class_method:1,public_instance_methods:1,"public_method_defined?":1,public_methods:1,push:1,putc:1,puts:1,quo:1,raise:1,rand:1,rassoc:1,read:1,read_nonblock:1,readchar:1,readline:1,readlines:1,readpartial:1,rehash:1,reject:1,"reject!":1,remainder:1,reopen:1,replace:1,require:1,"respond_to?":1,reverse:1,"reverse!":1,reverse_each:1,rewind:1,rindex:1,rjust:1,round:1,rstrip:1,"rstrip!":1,scan:1,seek:1,select:1,send:1,set_trace_func:1,shift:1,singleton_method_added:1,singleton_methods:1,size:1,sleep:1,slice:1,"slice!":1,sort:1,"sort!":1,sort_by:1,split:1,sprintf:1,squeeze:1,"squeeze!":1,srand:1,stat:1,step:1,store:1,strip:1,"strip!":1,sub:1,"sub!":1,succ:1,"succ!":1,sum:1,superclass:1,swapcase:1,"swapcase!":1,sync:1,syscall:1,sysopen:1,sysread:1,sysseek:1,system:1,syswrite:1,taint:1,"tainted?":1,tell:1,test:1,"throw":1,times:1,to_a:1,to_ary:1,to_f:1,to_hash:1,to_i:1,to_int:1,to_io:1,to_proc:1,to_s:1,to_str:1,to_sym:1,tr:1,"tr!":1,tr_s:1,"tr_s!":1,trace_var:1,transpose:1,trap:1,truncate:1,"tty?":1,type:1,ungetc:1,uniq:1,"uniq!":1,unpack:1,unshift:1,untaint:1,untrace_var:1,upcase:1,"upcase!":1,update:1,upto:1,"value?":1,values:1,values_at:1,warn:1,write:1,write_nonblock:1,"zero?":1,zip:1}};var h={cN:"yardoctag",b:"@[A-Za-z]+"};var d={cN:"comment",b:"#",e:"$",c:[h]};var c={cN:"comment",b:"^\\=begin",e:"^\\=end",c:[h],r:10};var b={cN:"comment",b:"^__END__",e:"\\n$"};var u={cN:"subst",b:"#\\{",e:"}",l:g,k:n};var p=[hljs.BE,u];var s={cN:"string",b:"'",e:"'",c:p,r:0};var r={cN:"string",b:'"',e:'"',c:p,r:0};var q={cN:"string",b:"%[qw]?\\(",e:"\\)",c:p,r:10};var o={cN:"string",b:"%[qw]?\\[",e:"\\]",c:p,r:10};var m={cN:"string",b:"%[qw]?{",e:"}",c:p,r:10};var l={cN:"string",b:"%[qw]?<",e:">",c:p,r:10};var k={cN:"string",b:"%[qw]?/",e:"/",c:p,r:10};var j={cN:"string",b:"%[qw]?%",e:"%",c:p,r:10};var i={cN:"string",b:"%[qw]?-",e:"-",c:p,r:10};var t={cN:"string",b:"%[qw]?\\|",e:"\\|",c:p,r:10};var e={cN:"function",b:"\\bdef\\s+",e:" |$|;",l:g,k:n,c:[{cN:"title",b:a,l:g,k:n},{cN:"params",b:"\\(",e:"\\)",l:g,k:n},d,c,b]};var f={cN:"identifier",b:g,l:g,k:n,r:0};var v=[d,c,b,s,r,q,o,m,l,k,j,i,t,{cN:"class",b:"\\b(class|module)\\b",e:"$|;",k:{"class":1,module:1},c:[{cN:"title",b:"[A-Za-z_]\\w*(::\\w+)*(\\?|\\!)?",r:0},{cN:"inheritance",b:"<\\s*",c:[{cN:"parent",b:"("+hljs.IR+"::)?"+hljs.IR}]},d,c,b]},e,{cN:"constant",b:"(::)?([A-Z]\\w*(::)?)+",r:0},{cN:"symbol",b:":",c:[s,r,q,o,m,l,k,j,i,t,f],r:0},{cN:"number",b:"(\\b0[0-7_]+)|(\\b0x[0-9a-fA-F_]+)|(\\b[1-9][0-9_]*(\\.[0-9_]+)?)|[0_]\\b",r:0},{cN:"number",b:"\\?\\w"},{cN:"variable",b:"(\\$\\W)|((\\$|\\@\\@?)(\\w+))"},f,{b:"("+hljs.RSR+")\\s*",c:[d,c,b,{cN:"regexp",b:"/",e:"/[a-z]*",i:"\\n",c:[hljs.BE]}],r:0}];u.c=v;e.c[1].c=v;return{dM:{l:g,k:n,c:v}}}();hljs.LANGUAGES.diff={cI:true,dM:{c:[{cN:"chunk",b:"^\\@\\@ +\\-\\d+,\\d+ +\\+\\d+,\\d+ +\\@\\@$",r:10},{cN:"chunk",b:"^\\*\\*\\* +\\d+,\\d+ +\\*\\*\\*\\*$",r:10},{cN:"chunk",b:"^\\-\\-\\- +\\d+,\\d+ +\\-\\-\\-\\-$",r:10},{cN:"header",b:"Index: ",e:"$"},{cN:"header",b:"=====",e:"=====$"},{cN:"header",b:"^\\-\\-\\-",e:"$"},{cN:"header",b:"^\\*{3} ",e:"$"},{cN:"header",b:"^\\+\\+\\+",e:"$"},{cN:"header",b:"\\*{5}",e:"\\*{5}$"},{cN:"addition",b:"^\\+",e:"$"},{cN:"deletion",b:"^\\-",e:"$"},{cN:"change",b:"^\\!",e:"$"}]}};hljs.LANGUAGES.javascript={dM:{k:{keyword:{"in":1,"if":1,"for":1,"while":1,"finally":1,"var":1,"new":1,"function":1,"do":1,"return":1,"void":1,"else":1,"break":1,"catch":1,"instanceof":1,"with":1,"throw":1,"case":1,"default":1,"try":1,"this":1,"switch":1,"continue":1,"typeof":1,"delete":1},literal:{"true":1,"false":1,"null":1}},c:[hljs.ASM,hljs.QSM,hljs.CLCM,hljs.CBLCLM,hljs.CNM,{b:"("+hljs.RSR+"|case|return|throw)\\s*",k:{"return":1,"throw":1,"case":1},c:[hljs.CLCM,hljs.CBLCLM,{cN:"regexp",b:"/",e:"/[gim]*",c:[{b:"\\\\/"}]}],r:0},{cN:"function",b:"\\bfunction\\b",e:"{",k:{"function":1},c:[{cN:"title",b:"[A-Za-z$_][0-9A-Za-z$_]*"},{cN:"params",b:"\\(",e:"\\)",c:[hljs.ASM,hljs.QSM,hljs.CLCM,hljs.CBLCLM]}]}]}};hljs.LANGUAGES.css=function(){var a={cN:"function",b:hljs.IR+"\\(",e:"\\)",c:[{eW:true,eE:true,c:[hljs.NM,hljs.ASM,hljs.QSM]}]};return{cI:true,dM:{i:"[=/|']",c:[hljs.CBLCLM,{cN:"id",b:"\\#[A-Za-z0-9_-]+"},{cN:"class",b:"\\.[A-Za-z0-9_-]+",r:0},{cN:"attr_selector",b:"\\[",e:"\\]",i:"$"},{cN:"pseudo",b:":(:)?[a-zA-Z0-9\\_\\-\\+\\(\\)\\\"\\']+"},{cN:"at_rule",b:"@(font-face|page)",l:"[a-z-]+",k:{"font-face":1,page:1}},{cN:"at_rule",b:"@",e:"[{;]",eE:true,k:{"import":1,page:1,media:1,charset:1},c:[a,hljs.ASM,hljs.QSM,hljs.NM]},{cN:"tag",b:hljs.IR,r:0},{cN:"rules",b:"{",e:"}",i:"[^\\s]",r:0,c:[hljs.CBLCLM,{cN:"rule",b:"[^\\s]",rB:true,e:";",eW:true,c:[{cN:"attribute",b:"[A-Z\\_\\.\\-]+",e:":",eE:true,i:"[^\\s]",starts:{cN:"value",eW:true,eE:true,c:[a,hljs.NM,hljs.QSM,hljs.ASM,hljs.CBLCLM,{cN:"hexcolor",b:"\\#[0-9A-F]+"},{cN:"important",b:"!important"}]}}]}]}]}}}();hljs.LANGUAGES.xml=function(){var b="[A-Za-z0-9\\._:-]+";var a={eW:true,c:[{cN:"attribute",b:b,r:0},{b:'="',rB:true,e:'"',c:[{cN:"value",b:'"',eW:true}]},{b:"='",rB:true,e:"'",c:[{cN:"value",b:"'",eW:true}]},{b:"=",c:[{cN:"value",b:"[^\\s/>]+"}]}]};return{cI:true,dM:{c:[{cN:"pi",b:"<\\?",e:"\\?>",r:10},{cN:"doctype",b:"<!DOCTYPE",e:">",r:10,c:[{b:"\\[",e:"\\]"}]},{cN:"comment",b:"<!--",e:"-->",r:10},{cN:"cdata",b:"<\\!\\[CDATA\\[",e:"\\]\\]>",r:10},{cN:"tag",b:"<style",e:">",k:{title:{style:1}},c:[a],starts:{cN:"css",e:"</style>",rE:true,sL:"css"}},{cN:"tag",b:"<script",e:">",k:{title:{script:1}},c:[a],starts:{cN:"javascript",e:"<\/script>",rE:true,sL:"javascript"}},{cN:"vbscript",b:"<%",e:"%>",sL:"vbscript"},{cN:"tag",b:"</?",e:"/?>",c:[{cN:"title",b:"[^ />]+"},a]}]}}}();hljs.LANGUAGES.java={dM:{k:{"false":1,"synchronized":1,"int":1,"abstract":1,"float":1,"private":1,"char":1,"interface":1,"boolean":1,"static":1,"null":1,"if":1,"const":1,"for":1,"true":1,"while":1,"long":1,"throw":1,strictfp:1,"finally":1,"protected":1,"extends":1,"import":1,"native":1,"final":1,"implements":1,"return":1,"void":1,"enum":1,"else":1,"break":1,"transient":1,"new":1,"catch":1,"instanceof":1,"byte":1,"super":1,"class":1,"volatile":1,"case":1,assert:1,"short":1,"package":1,"default":1,"double":1,"public":1,"try":1,"this":1,"switch":1,"continue":1,"throws":1},c:[{cN:"javadoc",b:"/\\*\\*",e:"\\*/",c:[{cN:"javadoctag",b:"@[A-Za-z]+"}],r:10},hljs.CLCM,hljs.CBLCLM,hljs.ASM,hljs.QSM,{cN:"class",b:"(class |interface )",e:"{",k:{"class":1,"interface":1},i:":",c:[{b:"(implements|extends)",k:{"extends":1,"implements":1},r:10},{cN:"title",b:hljs.UIR}]},hljs.CNM,{cN:"annotation",b:"@[A-Za-z]+"}]}};hljs.LANGUAGES.php={cI:true,dM:{k:{and:1,include_once:1,list:1,"abstract":1,global:1,"private":1,echo:1,"interface":1,as:1,"static":1,endswitch:1,array:1,"null":1,"if":1,endwhile:1,or:1,"const":1,"for":1,endforeach:1,self:1,"var":1,"while":1,isset:1,"public":1,"protected":1,exit:1,foreach:1,"throw":1,elseif:1,"extends":1,include:1,__FILE__:1,empty:1,require_once:1,"function":1,"do":1,xor:1,"return":1,"implements":1,parent:1,clone:1,use:1,__CLASS__:1,__LINE__:1,"else":1,"break":1,print:1,"eval":1,"new":1,"catch":1,__METHOD__:1,"class":1,"case":1,exception:1,php_user_filter:1,"default":1,die:1,require:1,__FUNCTION__:1,enddeclare:1,"final":1,"try":1,"this":1,"switch":1,"continue":1,endfor:1,endif:1,declare:1,unset:1,"true":1,"false":1,namespace:1},c:[hljs.CLCM,hljs.HCM,{cN:"comment",b:"/\\*",e:"\\*/",c:[{cN:"phpdoc",b:"\\s@[A-Za-z]+",r:10}]},hljs.CNM,hljs.inherit(hljs.ASM,{i:null}),hljs.inherit(hljs.QSM,{i:null}),{cN:"variable",b:"\\$[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*"},{cN:"preprocessor",b:"<\\?php",r:10},{cN:"preprocessor",b:"\\?>"}]}};hljs.LANGUAGES.python=function(){var c={cN:"string",b:"(u|b)?r?'''",e:"'''",r:10};var b={cN:"string",b:'(u|b)?r?"""',e:'"""',r:10};var a={cN:"string",b:"(u|r|ur|b|br)'",e:"'",c:[hljs.BE],r:10};var f={cN:"string",b:'(u|r|ur|b|br)"',e:'"',c:[hljs.BE],r:10};var d={cN:"title",b:hljs.UIR};var e={cN:"params",b:"\\(",e:"\\)",c:[c,b,a,f,hljs.ASM,hljs.QSM]};return{dM:{k:{keyword:{and:1,elif:1,is:1,global:1,as:1,"in":1,"if":1,from:1,raise:1,"for":1,except:1,"finally":1,print:1,"import":1,pass:1,"return":1,exec:1,"else":1,"break":1,not:1,"with":1,"class":1,assert:1,yield:1,"try":1,"while":1,"continue":1,del:1,or:1,def:1,lambda:1,nonlocal:10},built_in:{None:1,True:1,False:1,Ellipsis:1,NotImplemented:1}},i:"(</|->|\\?)",c:[hljs.HCM,c,b,a,f,hljs.ASM,hljs.QSM,{cN:"function",b:"\\bdef ",e:":",i:"$",k:{def:1},c:[d,e],r:10},{cN:"class",b:"\\bclass ",e:":",i:"[${]",k:{"class":1},c:[d,e],r:10},hljs.CNM,{cN:"decorator",b:"@",e:"$"}]}}}();hljs.LANGUAGES.sql={cI:true,dM:{i:"[^\\s]",c:[{cN:"operator",b:"(begin|start|commit|rollback|savepoint|lock|alter|create|drop|rename|call|delete|do|handler|insert|load|replace|select|truncate|update|set|show|pragma)\\b",e:";|$",k:{keyword:{all:1,partial:1,global:1,month:1,current_timestamp:1,using:1,go:1,revoke:1,smallint:1,indicator:1,"end-exec":1,disconnect:1,zone:1,"with":1,character:1,assertion:1,to:1,add:1,current_user:1,usage:1,input:1,local:1,alter:1,match:1,collate:1,real:1,then:1,rollback:1,get:1,read:1,timestamp:1,session_user:1,not:1,integer:1,bit:1,unique:1,day:1,minute:1,desc:1,insert:1,execute:1,like:1,ilike:2,level:1,decimal:1,drop:1,"continue":1,isolation:1,found:1,where:1,constraints:1,domain:1,right:1,national:1,some:1,module:1,transaction:1,relative:1,second:1,connect:1,escape:1,close:1,system_user:1,"for":1,deferred:1,section:1,cast:1,current:1,sqlstate:1,allocate:1,intersect:1,deallocate:1,numeric:1,"public":1,preserve:1,full:1,"goto":1,initially:1,asc:1,no:1,key:1,output:1,collation:1,group:1,by:1,union:1,session:1,both:1,last:1,language:1,constraint:1,column:1,of:1,space:1,foreign:1,deferrable:1,prior:1,connection:1,unknown:1,action:1,commit:1,view:1,or:1,first:1,into:1,"float":1,year:1,primary:1,cascaded:1,except:1,restrict:1,set:1,references:1,names:1,table:1,outer:1,open:1,select:1,size:1,are:1,rows:1,from:1,prepare:1,distinct:1,leading:1,create:1,only:1,next:1,inner:1,authorization:1,schema:1,corresponding:1,option:1,declare:1,precision:1,immediate:1,"else":1,timezone_minute:1,external:1,varying:1,translation:1,"true":1,"case":1,exception:1,join:1,hour:1,"default":1,"double":1,scroll:1,value:1,cursor:1,descriptor:1,values:1,dec:1,fetch:1,procedure:1,"delete":1,and:1,"false":1,"int":1,is:1,describe:1,"char":1,as:1,at:1,"in":1,varchar:1,"null":1,trailing:1,any:1,absolute:1,current_time:1,end:1,grant:1,privileges:1,when:1,cross:1,check:1,write:1,current_date:1,pad:1,begin:1,temporary:1,exec:1,time:1,update:1,catalog:1,user:1,sql:1,date:1,on:1,identity:1,timezone_hour:1,natural:1,whenever:1,interval:1,work:1,order:1,cascade:1,diagnostics:1,nchar:1,having:1,left:1,call:1,"do":1,handler:1,load:1,replace:1,truncate:1,start:1,lock:1,show:1,pragma:1},aggregate:{count:1,sum:1,min:1,max:1,avg:1}},c:[{cN:"string",b:"'",e:"'",c:[hljs.BE,{b:"''"}],r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE,{b:'""'}],r:0},{cN:"string",b:"`",e:"`",c:[hljs.BE]},hljs.CNM,{b:"\\n"}]},hljs.CBLCLM,{cN:"comment",b:"--",e:"$"}]}};hljs.LANGUAGES.ini={cI:true,dM:{i:"[^\\s]",c:[{cN:"comment",b:";",e:"$"},{cN:"title",b:"^\\[",e:"\\]"},{cN:"setting",b:"^[a-z0-9_\\[\\]]+[ \\t]*=[ \\t]*",e:"$",c:[{cN:"value",eW:true,k:{on:1,off:1,"true":1,"false":1,yes:1,no:1},c:[hljs.QSM,hljs.NM]}]}]}};hljs.LANGUAGES.perl=function(){var c={getpwent:1,getservent:1,quotemeta:1,msgrcv:1,scalar:1,kill:1,dbmclose:1,undef:1,lc:1,ma:1,syswrite:1,tr:1,send:1,umask:1,sysopen:1,shmwrite:1,vec:1,qx:1,utime:1,local:1,oct:1,semctl:1,localtime:1,readpipe:1,"do":1,"return":1,format:1,read:1,sprintf:1,dbmopen:1,pop:1,getpgrp:1,not:1,getpwnam:1,rewinddir:1,qq:1,fileno:1,qw:1,endprotoent:1,wait:1,sethostent:1,bless:1,s:1,opendir:1,"continue":1,each:1,sleep:1,endgrent:1,shutdown:1,dump:1,chomp:1,connect:1,getsockname:1,die:1,socketpair:1,close:1,flock:1,exists:1,index:1,shmget:1,sub:1,"for":1,endpwent:1,redo:1,lstat:1,msgctl:1,setpgrp:1,abs:1,exit:1,select:1,print:1,ref:1,gethostbyaddr:1,unshift:1,fcntl:1,syscall:1,"goto":1,getnetbyaddr:1,join:1,gmtime:1,symlink:1,semget:1,splice:1,x:1,getpeername:1,recv:1,log:1,setsockopt:1,cos:1,last:1,reverse:1,gethostbyname:1,getgrnam:1,study:1,formline:1,endhostent:1,times:1,chop:1,length:1,gethostent:1,getnetent:1,pack:1,getprotoent:1,getservbyname:1,rand:1,mkdir:1,pos:1,chmod:1,y:1,substr:1,endnetent:1,printf:1,next:1,open:1,msgsnd:1,readdir:1,use:1,unlink:1,getsockopt:1,getpriority:1,rindex:1,wantarray:1,hex:1,system:1,getservbyport:1,endservent:1,"int":1,chr:1,untie:1,rmdir:1,prototype:1,tell:1,listen:1,fork:1,shmread:1,ucfirst:1,setprotoent:1,"else":1,sysseek:1,link:1,getgrgid:1,shmctl:1,waitpid:1,unpack:1,getnetbyname:1,reset:1,chdir:1,grep:1,split:1,require:1,caller:1,lcfirst:1,until:1,warn:1,"while":1,values:1,shift:1,telldir:1,getpwuid:1,my:1,getprotobynumber:1,"delete":1,and:1,sort:1,uc:1,defined:1,srand:1,accept:1,"package":1,seekdir:1,getprotobyname:1,semop:1,our:1,rename:1,seek:1,"if":1,q:1,chroot:1,sysread:1,setpwent:1,no:1,crypt:1,getc:1,chown:1,sqrt:1,write:1,setnetent:1,setpriority:1,foreach:1,tie:1,sin:1,msgget:1,map:1,stat:1,getlogin:1,unless:1,elsif:1,truncate:1,exec:1,keys:1,glob:1,tied:1,closedir:1,ioctl:1,socket:1,readlink:1,"eval":1,xor:1,readline:1,binmode:1,setservent:1,eof:1,ord:1,bind:1,alarm:1,pipe:1,atan2:1,getgrent:1,exp:1,time:1,push:1,setgrent:1,gt:1,lt:1,or:1,ne:1,m:1};var d={cN:"subst",b:"[$@]\\{",e:"}",k:c,r:10};var b={cN:"variable",b:"\\$\\d"};var a={cN:"variable",b:"[\\$\\%\\@\\*](\\^\\w\\b|#\\w+(\\:\\:\\w+)*|[^\\s\\w{]|{\\w+}|\\w+(\\:\\:\\w*)*)"};var g=[hljs.BE,d,b,a];var f={b:"->",c:[{b:hljs.IR},{b:"{",e:"}"}]};var e=[b,a,hljs.HCM,{cN:"comment",b:"^(__END__|__DATA__)",e:"\\n$",r:5},f,{cN:"string",b:"q[qwxr]?\\s*\\(",e:"\\)",c:g,r:5},{cN:"string",b:"q[qwxr]?\\s*\\[",e:"\\]",c:g,r:5},{cN:"string",b:"q[qwxr]?\\s*\\{",e:"\\}",c:g,r:5},{cN:"string",b:"q[qwxr]?\\s*\\|",e:"\\|",c:g,r:5},{cN:"string",b:"q[qwxr]?\\s*\\<",e:"\\>",c:g,r:5},{cN:"string",b:"qw\\s+q",e:"q",c:g,r:5},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"string",b:'"',e:'"',c:g,r:0},{cN:"string",b:"`",e:"`",c:[hljs.BE]},{cN:"string",b:"{\\w+}",r:0},{cN:"string",b:"-?\\w+\\s*\\=\\>",r:0},{cN:"number",b:"(\\b0[0-7_]+)|(\\b0x[0-9a-fA-F_]+)|(\\b[1-9][0-9_]*(\\.[0-9_]+)?)|[0_]\\b",r:0},{cN:"regexp",b:"(s|tr|y)/(\\\\.|[^/])*/(\\\\.|[^/])*/[a-z]*",r:10},{cN:"regexp",b:"(m|qr)?/",e:"/[a-z]*",c:[hljs.BE],r:0},{cN:"sub",b:"\\bsub\\b",e:"(\\s*\\(.*?\\))?[;{]",k:{sub:1},r:5},{cN:"operator",b:"-\\w\\b",r:0},{cN:"pod",b:"\\=\\w",e:"\\=cut"}];d.c=e;f.c[1].c=e;return{dM:{k:c,c:e}}}();hljs.LANGUAGES.cpp=function(){var b={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};var a={cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:b,r:10};a.c=[a];return{dM:{k:b,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'",e:"[^\\\\]'",i:"[^\\\\][^']"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},a]}}}();</script>

<script>hljs.initHighlightingOnLoad();</script>
    </div>
</body>
</html>