<!DOCTYPE html>
<meta charset="utf-8">
<head>
<style>

    @import url('../../static/style/slide.css');

    body {
      font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
    }

    #PercentL {
            position: fixed;
            top: 200px;
            left: 50px;}		
    
    .JAX {
            position: relative;
            top: 550px;
            //left: 250px;
            }
			
    .axis path,
    .axis line {
        fill: none;
        stroke: #000;
        shape-rendering: crispEdges;
        font: 20px;
    }

    
    text {
        font: 18px sans-serif;
    }

    
    .RLine {
        fill: none;
        stroke: red;
        stroke-width: 1.5px;
    }
    .GLine {
        fill: none;
        stroke: green;
        stroke-width: 1.5px;
    }

    .BLine {
        fill: none;
        stroke: blue;
        stroke-width: 1.5px;
    }
	
			
    svg {
        position: fixed;
        top: -50px;
        left: 100px;
    }
    
    .light {
        fill: none;
        stroke: #666;
        stroke-width: 1px;
    }
 	
    .matchLight {
        fill: none;
        stroke: #666;
        stroke-width: 1px;
    }
       
    .inputholder {
        position: fixed;
        top: 200px;
        left: 150px;
		font-size: 20px;
        }
 
	.inputholder2 {
		position: fixed;
		top: 370px;
		left: 150px;
		font-size: 20px;
	}

	.inputholder3 {
		position: fixed;
		top: 565px;
		left: 560px;
		font-size: 18px;
		}
</style>
<script type="text/javascript" src="../../static/js/slide.js"></script>
<script type="text/javascript"
  src="https://c328740.ssl.cf1.rackcdn.com/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
</script>
<script type="text/javascript" src="../../static/js/d3.js"></script>
</head>
<body onload="formatImages(50.0);">
    <script>
        var margin = {top: 20, right: 20, bottom: 30, left: 40},
        width = 980 - margin.left - margin.right,
        height = 650 - margin.top - margin.bottom;

		var x = d3.scale.linear()
		.range([30, 500 + 30]);

		var y = d3.scale.linear()
		.range([400 - 10, -10]);

		var xAxis = d3.svg.axis()
		.scale(x)
		.orient("bottom");

		var yAxis = d3.svg.axis()
		.scale(y)
		.ticks(5)
		.orient("left");

		var Rline = d3.svg.line()
		.x(function(d) { return x(d.lambda); })
		.y(function(d) { return y(d.R); });

		var Gline = d3.svg.line()
		.x(function(d) { return x(d.lambda); })
		.y(function(d) { return y(d.G); });

		var Bline = d3.svg.line()
		.x(function(d) { return x(d.lambda); })
		.y(function(d) { return y(d.B); });
		
        var svg = d3.select("body").append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        .append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

		d3.tsv("../../static/data/neitz_CMFs.tsv", function(error, CMFs) {
		  CMFs.forEach(function(d) {
			d.R = +d.R;
			d.G = +d.G;
			d.B = +d.B;
			d.lambda = +d.lambda;
		  });
		
		x.domain(d3.extent(CMFs, function(d) { return d.lambda; }));
        y.domain(d3.extent(CMFs, function(d) { return d.R; }));

		svg.append("g")
			.attr("class", "x axis")
			.attr("transform", "translate(390,550)")
			.call(xAxis)
			.append("text")
			.attr("x", (500 - 30) / 2)
			.attr("y", 65)
			.text("wavelength (nm)");
			 
		svg.append("g")
			.attr("class", "y axis")
			.attr("transform", "translate(390,150)")
			.call(yAxis)
			.append("text")
			.attr("transform", "rotate(-90)")
			.attr("y", 6)
			.attr("dy", ".71em")
			.style("text-anchor", "end")
			.text("intensity");

		// light:
		svg.selectAll(".light")
			.data([1])
			.enter().append("circle")
			.attr("class", "light")
			.attr("cx", 60)
			.attr("cy", 350)
			.attr("r", 40)
            .style("fill", wavelength_to_RGB(550));

		d3.select("body")
			.append("div")
			.attr("class","inputholder")
			.append("input")
			.attr("id", "spectral")
			.attr("type", "range")
			.attr("min", 390)
			.attr("max", 750)
			.attr("step", 1)
			.attr("value", 550);

		d3.select(".inputholder").append("span")
			.attr("id", "light_text")
			.text("w: ")
			.append("span")
			.attr("id", "light_val")
			.text(550 + " nm");
		
		// match light //
        svg.selectAll(".matchLight")
			.data([1])
			.enter().append("circle")
			.attr("class", "matchLight")
			.attr("cx", 60)
			.attr("cy", 350)
			.attr("r", 40)
			.attr("transform", "translate(100,0)")
            .style("fill", d3.rgb(normRGB(0, "R"),normRGB(0, "G"),normRGB(0, "B")));
        
        d3.select("body")
			.append("div")
			.attr("class","inputholder2")
			.append("input")
			.attr("id", "matchR")
			.attr("type", "range")
			.attr("min", -0.4)
			.attr("max", 1.8)
			.attr("step", 0.01)
			.attr("value", 0);
		
        d3.select(".inputholder2").append("span")
			.attr("id", "R_text")
			.text(" R: ")
			.append("span")
			.attr("id", "matchR_val")
			.text(0);
        d3.select(".inputholder2").append("br");
		
        d3.select(".inputholder2")
			.append("input")
			.attr("id", "matchG")
			.attr("type", "range")
			.attr("min", -0.4)
			.attr("max", 1.8)
			.attr("step", 0.01)
			.attr("value", 0);
		
        d3.select(".inputholder2").append("span")
			.attr("id", "G_text")
			.text(" G: ")
			.append("span")
			.attr("id", "matchG_val")
			.text(0);
        d3.select(".inputholder2").append("br");
		
        d3.select(".inputholder2")
			.append("input")
			.attr("id", "matchB")
			.attr("type", "range")
			.attr("min", -0.4)
			.attr("max", 1.8)
			.attr("step", 0.01)
			.attr("value", 0);
        
        d3.select(".inputholder2").append("span")
			.attr("id", "B_text")
			.text(" B: ")
			.append("span")
			.attr("id", "matchB_val")
			.text(0);
			
        d3.select("body")
			.append("div")
			.attr("class","inputholder3")
			.append("input")
			.attr("id", "showRGB")
			.attr("type", "checkbox")
		d3.select(".inputholder3").append("span")
			.text(" cheat");
		
		d3.select("svg").append("text")
			.attr("x", "50")
			.attr("y", "320")
			.text("target color");
		d3.select("svg").append("text")
			.attr("x", "160")
			.attr("y", "320")
			.text("match color");        
        
		d3.select("#spectral").on("change", lightChange)
		d3.select("#matchR").on("change", matchR)
		d3.select("#matchG").on("change", matchG)
		d3.select("#matchB").on("change", matchB)
        d3.select("#showRGB").on("change", showRGB)
		
		var Ramp = 0,
			Gamp = 0,
			Bamp = 0,
            Rval = normRGB(Ramp, "R"),
            Gval = normRGB(Gamp, "G"),
            Bval = normRGB(Bamp, "B"),
			wavelength = 550,
			checked = false;
			RGBdata = [
						[wavelength, Ramp, 'red'], 
						[wavelength, Gamp, 'green'], 
						[wavelength, Bamp, 'blue']];

		svg.selectAll("RGB")
			.data(RGBdata)		
			.enter().append("circle")
			.attr("class", "RGB")
			.attr("transform", "translate(390,150)")
			.attr("cx", function(d) { return x(d[0]);})
			.attr("cy", function(d) { return y(d[1]);})
			.attr("r", 5)
			.style("fill", function(d) { return d[2];});

        function normRGB(amp, COL) {
				cmf = [];
				for (var i = 0; i < CMFs.length; i++) {
					cmf.push(CMFs[i][COL])
				};
				console.log(COL, d3.max(cmf));

				range = d3.max(cmf) + Math.abs(d3.min(cmf));
				out = Math.abs(Math.round((amp) / range * 255));

				if (out > 255) {
					out = 255;
					}
				return out;
                };
    
		function showRGB() {
			if (checked == true) {
				d3.selectAll(".RLine").remove();
				d3.selectAll(".GLine").remove();
				d3.selectAll(".BLine").remove();	
				checked = false;}
			else {
				svg.append("path")
					.datum(CMFs)
					.attr("transform", "translate(390,150)")
					.attr("class", "RLine")
					.attr("d", Rline);

				svg.append("path")
					.datum(CMFs)
					.attr("transform", "translate(390,150)")
					.attr("class", "GLine")
					.attr("d", Gline);

				svg.append("path")
					.datum(CMFs)
					.attr("transform", "translate(390,150)")
					.attr("class", "BLine")
					.attr("d", Bline);	
				checked = true;}

		};
        
		function matchR() {
			Ramp = parseFloat(this.value);
			Rval = _match("R", Ramp);
			}
		function matchG() {
			Gamp = parseFloat(this.value);
			Gval = _match("G", Gamp);
			}
		function matchB() {
			Bamp = parseFloat(this.value);
			Bval = _match("B", Bamp);
			}
			
        function _match(COL, amp) {
			val = COL + "val";
			RGBdata = [
						[wavelength, Ramp, 'red'], 
						[wavelength, Gamp, 'green'], 
						[wavelength, Bamp, 'blue']];
			d3.selectAll(".RGB").remove();
            d3.selectAll("#match" + COL + "_val").remove();

            d3.select("#" + COL + "_text").append("span")
				.attr("id", "match" + COL + "_val")
				.text(amp);

			svg.selectAll("RGB")
				.data(RGBdata)		
				.enter().append("circle")
				.attr("class", "RGB")
				.attr("transform", "translate(390,150)")
				.attr("cx", function(d) { return x(d[0]);})
				.attr("cy", function(d) { return y(d[1]);})
				.attr("r", 5)
				.style("fill", function(d) { return d[2];});
			
			// set appropriate val:
			if (val === "Rval") {
				_val = Rval;
				};
			if (val === "Gval") {
				_val = Gval;
				};
			if (val === "Bval") {
				_val = Bval;
				};
			
			// decide whether to update match or test color
			if (amp >= 0) {
				
				_val = normRGB(amp, COL);
				console.log(wavelength_to_RGB(wavelength), d3.rgb(Rval, Gval, Bval));
				col_ = d3.rgb(Rval, Gval, Bval);          
				light_to_update = "matchLight";
				x_loc = 160;
			}
			else {
				console.log(COL);
				col_ = wavelength_to_RGB(wavelength);
				col_[COL.toLowerCase()] = normRGB(amp, COL);
				light_to_update = "light";
				x_loc = 60;
            }
			
			d3.selectAll("." + light_to_update).remove();
            svg.selectAll("." + light_to_update)
				.data([1])
				.enter().append("circle")
				.attr("class", light_to_update)
				.attr("cx", x_loc)
				.attr("cy", 350)
				.attr("r", 40)
				.style("fill", col_)
				.style("opacity", 1);
		return _val	
        };

        function lightChange() {
			wavelength = parseInt(this.value);
			console.log(wavelength_to_RGB(wavelength));
			RGBdata = [
						[wavelength, Ramp, 'red'], 
						[wavelength, Gamp, 'green'], 
						[wavelength, Bamp, 'blue']];

            d3.selectAll(".light").remove();
            d3.selectAll("#light_val").remove();
            d3.selectAll(".RGB").remove();
    
            d3.select("#light_text").append("span")
				.attr("id", "light_val")
				.text(this.value + " nm");

            svg.selectAll(".light")
				.data([1])
				.enter().append("circle")
				.attr("class", "light")
				.attr("cx", 60)
				.attr("cy", 350)
				.attr("r", 40)
				.style("fill", wavelength_to_RGB(wavelength))
				.style("opacity", 1);

			svg.selectAll("RGB")
				.data(RGBdata)		
				.enter().append("circle")
				.attr("class", "RGB")
				.attr("transform", "translate(390,150)")
				.attr("cx", function(d) { return x(d[0]);})
				.attr("cy", function(d) { return y(d[1]);})
				.attr("r", 5)
				.style("fill", function(d) { return d[2];});
			};	
		});
        
        function wavelength_to_RGB(WL) {
        // ported from Sz-Chin Steven LIN matlab and Dan Bruton's fortran code
            
        if (WL>=380 && WL<=440) {
        R = -1.*(WL-440)/(440-380);
        G = 0;
        B = 1;
        };
        if (WL>=440 && WL<=490) {
        R = 0;
        G = (WL-440)/(490-440);
        B = 1;
        };
        if (WL>=490 && WL<=510) {
        R = 0;
        G = 1;
        B = -1.*(WL-510)/(510-490);
        };
        if (WL>=510 && WL<=580) {
        R = (WL-510)/(580-510);
        G = 1;
        B = 0;
        };
        if (WL>=580 && WL<=645) {
        R = 1;
        G = -1.*(WL-645)/(645-580);
        B = 0;
        };
        if (WL>=645 && WL<=780) {
        R = 1;
        G = 0;
        B = 0;
        };
        
        // LET THE INTENSITY SSS FALL OFF NEAR THE VISION LIMITS
        if (WL>700) {
        SSS=0.3+0.7* (780-WL)/(780-700);
        }
        if (WL<420) {
        SSS=.3+.7*(WL-380)/(420-380);
        }
        else {
        SSS=1;
        };
        return d3.rgb(SSS * R * 255, SSS * G * 255, SSS * B * 255)
        };
        
        </script>

<h2 class="slideTitle">color spaces</h2>
  <!--<div class="JAX">
      \[\begin{bmatrix}  
        l_r & l_g & l_b\\
        m_r & m_g & m_b\\
        s_r & s_g & s_b\\
      \end{bmatrix}^{-1} \quad
      \begin{bmatrix}  
        l(\lambda)\\
        m(\lambda)\\
        s(\lambda)\\
      \end{bmatrix} =
      \begin{bmatrix}  
        r(\lambda)\\
        g(\lambda)\\
        b(\lambda)\\
      \end{bmatrix}
    \]
  </div>-->

  <div class="JAX">
      \[\begin{bmatrix}  
        l_r & l_g & l_b\\
        m_r & m_g & m_b\\
        s_r & s_g & s_b\\
      \end{bmatrix} \quad
      \begin{bmatrix}  
        r(\lambda)\\
        g(\lambda)\\
        b(\lambda)\\
      \end{bmatrix}
      =
      \begin{bmatrix}  
        l(\lambda)\\
        m(\lambda)\\
        s(\lambda)\\
      \end{bmatrix}
    \]
  </div>
  <div>
    <!--<img src="../../static/figures/colorModel/PercentL.png" id="PercentL">-->
</div>

</body>
</html>